# 需求变更单

## 基本信息

| 项目 | 内容 |
|------|------|
| 变更编号 | RC-015 |
| 变更日期 | 2026-01-29 |
| 提出人 | |
| 优先级 | P2-中 |
| 影响范围 | 前端 |

---

## 1. 变更概述

> 优化查询结果表格的列宽展示逻辑，根据字段内容长度动态分配列宽，并支持列宽状态在编辑器标签页切换时持久化保留

---

## 2. 变更背景

### 2.1 现状问题

> 描述当前系统存在的问题或不足

- **列宽计算不合理**：当前列宽仅基于列名长度计算，即使数据内容很长，列也可能展示得很窄，用户需要手动调整才能看到完整内容
- **列宽状态丢失**：用户手动调整列宽后，切换编辑器标签页再切回来，调整的列宽会丢失，需要重新调整

### 2.2 变更原因

> 说明为什么需要进行这个变更

- 提升数据展示的可读性，减少用户手动调整列宽的频率
- 保持用户调整的列宽状态，提升操作体验的连续性

---

## 3. 变更内容

### 3.1 功能需求

> 详细描述需要实现的功能

#### 3.1.1 列宽动态计算

| 序号 | 功能点 | 描述 | 验收标准 |
|------|--------|------|----------|
| 1 | 综合计算列宽 | 列宽同时考虑表头名称长度和数据内容长度，取两者较大值 | 列宽能展示表头和大部分数据内容 |
| 2 | 数据采样范围 | 仅采样第一屏能展示的行数（约 10-20 行）计算内容长度，不扫描全部数据 | 计算性能良好，不因大数据量卡顿 |
| 3 | 最大列宽限制 | 列宽最大不超过 300px，防止单列过宽 | 超长内容的列宽不超过 300px |
| 4 | 最小列宽限制 | 列宽最小不低于 50px（已有逻辑） | 短内容的列宽不低于 50px |

#### 3.1.2 列宽状态持久化

| 序号 | 功能点 | 描述 | 验收标准 |
|------|--------|------|----------|
| 1 | 按编辑器标签页保存 | 列宽状态按编辑器标签页维度保存，切换标签页后恢复之前的列宽 | 切换编辑器标签页后，列宽保持用户调整的状态 |
| 2 | 重新执行 SQL 重置 | 重新执行 SQL 查询后，列宽重新计算（简化实现，不区分列结构是否变化） | 执行新查询后列宽按新结果自动计算 |

### 3.2 非功能需求

> 性能、安全、兼容性等要求

- 列宽计算应在 10ms 内完成，不阻塞 UI 渲染
- 采样行数根据可视区域高度动态计算（可视高度 / 行高）

---

## 4. 输入输出示例

### 示例 1：列宽动态计算

**场景：** 查询 `SELECT id, name, description FROM products`

| 列名 | 列名长度 | 数据示例（第一屏） | 数据最大长度 | 计算列宽 |
|------|---------|------------------|-------------|---------|
| id | 2字符 | 1, 2, 3... | 1字符 | 50px（最小值）|
| name | 4字符 | iPhone 15 Pro | 13字符 | 130px |
| description | 11字符 | 这是一个很长的描述... | 30字符 | 300px（最大值）|

### 示例 2：列宽持久化

**场景：** 用户在编辑器标签页 A 调整了列宽

1. 用户在标签页 A 执行查询，调整 `name` 列宽度为 150px
2. 用户切换到标签页 B 执行其他查询
3. 用户切回标签页 A
4. **期望结果**：`name` 列宽度仍为 150px

### 示例 3：重新执行 SQL

**场景：** 用户调整列宽后重新执行查询

1. 用户执行 `SELECT * FROM users`，调整 `email` 列宽度为 200px
2. 用户再次点击执行按钮（或按 F5）
3. **期望结果**：`email` 列宽度重新计算，不保留 200px

---

## 5. 影响分析

### 5.1 受影响的模块

> 列出需要修改的代码模块

| 模块 | 文件路径 | 修改类型 | 说明 |
|------|----------|----------|------|
| 结果表格组件 | src/renderer/components/ResultTable.vue | 修改 | 优化 initColumnWidths 计算逻辑 |
| 结果状态管理 | src/renderer/stores/result.ts | 修改 | 新增列宽状态存储，按编辑器标签页隔离 |

### 5.2 向后兼容性

- ✅ 完全兼容，仅改进现有列宽计算逻辑
- ✅ 用户手动调整列宽的操作方式不变

---

## 6. 测试用例

> 用于验证变更是否正确实现

| 用例ID | 场景 | 输入 | 期望结果 |
|--------|------|------|----------|
| TC01 | 短列名短数据 | 查询 id 列，数据为 1-9 | 列宽为最小值 50px |
| TC02 | 短列名长数据 | 查询 description 列，数据为长文本 | 列宽基于数据长度计算，最大 300px |
| TC03 | 长列名短数据 | 查询 created_at 列，数据为短日期 | 列宽基于列名长度计算 |
| TC04 | 超长数据 | 数据内容超过 100 字符 | 列宽不超过 300px |
| TC05 | 大数据量性能 | 查询返回 10 万行 | 列宽计算不卡顿（仅采样前 N 行）|
| TC06 | 手动调整列宽 | 拖动调整列宽 | 列宽按用户设置显示 |
| TC07 | 切换标签页保留列宽 | 调整列宽 → 切换标签页 → 切回 | 列宽保持用户调整的值 |
| TC08 | 重新执行 SQL 重置 | 调整列宽 → 重新执行同一 SQL | 列宽重新计算 |
| TC09 | NULL 值计算 | 数据包含 NULL 值 | NULL 按 "NULL" 4 字符计算 |

---

## 7. 备注

> 其他需要说明的事项

### 7.1 列宽计算公式

```
列宽 = min(max(表头宽度, 数据最大宽度, 50), 300)

其中：
- 表头宽度 = 列名字符数 × 单字符宽度（约 8-10px）+ 类型标签宽度
- 数据最大宽度 = max(前 N 行数据的字符数) × 单字符宽度
- N = 可视区域高度 / 行高（约 10-20 行）
```

### 7.2 设计决策

| 决策点 | 选择 | 原因 |
|--------|------|------|
| 数据采样范围 | 第一屏可见行 | 性能考虑，避免扫描大量数据 |
| 重新执行 SQL 后列宽 | 重置 | 简化实现，降低开发成本 |
| 是否需要重置按钮 | 否 | 需求简化，暂不需要 |

---

## 8. 需求确认记录

> 记录需求分析过程中的疑问和确认结果

| 日期 | 问题 | 确认结果 |
|------|------|----------|
| 2026-01-29 | 列宽计算是否考虑数据内容？ | ✅ 同时考虑表头名称和数据内容长度 |
| 2026-01-29 | 数据采样范围？ | ✅ 第一屏可见行，不扫描全部数据 |
| 2026-01-29 | 最大列宽限制？ | ✅ 300px |
| 2026-01-29 | 列宽持久化范围？ | ✅ 按编辑器标签页保存 |
| 2026-01-29 | 重新执行 SQL 后列宽？ | ✅ 重置（简化实现）|
| 2026-01-29 | 是否需要重置列宽按钮？ | ❌ 不需要 |
