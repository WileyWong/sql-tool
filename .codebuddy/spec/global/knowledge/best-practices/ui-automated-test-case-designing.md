# 前端页面自动化测试用例设计指南

> **版本**: 1.1.0  
> **最后更新**: 2024-12-24  
> **适用范围**: Web 前端 UI 自动化测试

---

## 目录

1. [概述](#1-概述)
2. [方法论与流程](#2-方法论与流程)
3. [测试用例设计原则](#3-测试用例设计原则)
4. [测试用例结构规范](#4-测试用例结构规范)
5. [测试场景分类与设计](#5-测试场景分类与设计)
6. [元素定位策略](#6-元素定位策略)
7. [断言设计策略](#7-断言设计策略)
8. [测试数据管理](#8-测试数据管理)
9. [工具选择策略](#9-工具选择策略)
10. [测试执行流程](#10-测试执行流程)
11. [重试与容错机制](#11-重试与容错机制)
12. [测试报告规范](#12-测试报告规范)
13. [最佳实践与反模式](#13-最佳实践与反模式)

---

## 1. 概述

### 1.1 文档目的

本文档定义前端 UI 自动化测试用例的设计规范、方法论和最佳实践，确保测试用例具备：
- **可读性**：开发、测试人员均可理解
- **可执行性**：可被自动化工具直接解析执行
- **可维护性**：易于更新和扩展
- **可重复性**：每次执行结果一致

### 1.2 适用场景

| 场景类型 | 适用性 | 说明 |
|---------|--------|------|
| 功能回归测试 | ✅ 强烈推荐 | 核心业务流程的自动化验证 |
| 冒烟测试 | ✅ 强烈推荐 | 快速验证主要功能可用性 |
| 表单验证测试 | ✅ 推荐 | 输入校验、边界值测试 |
| 性能基准测试 | ✅ 推荐 | Core Web Vitals 监控 |
| 视觉回归测试 | ⚠️ 有限支持 | 需配合截图对比工具 |
| 探索性测试 | ❌ 不适用 | 需要人工判断和创造性 |

### 1.3 测试金字塔定位

```
        /\
       /  \     E2E/UI 测试 (10%)
      /----\    - 本文档覆盖范围
     /      \   - 关键业务流程
    /--------\  集成测试 (20%)
   /          \ - API 测试
  /------------\单元测试 (70%)
 /              \- 组件测试
```

**原则**：UI 自动化测试聚焦于**关键业务路径**，避免过度自动化。

---

## 2. 方法论与流程

### 2.1 测试用例设计流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    UI 自动化测试用例设计流程                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐  │
│  │ 需求分析  │ -> │ 场景拆解  │ -> │ 操作建模  │ -> │ 断言设计  │  │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘  │
│       │               │               │               │         │
│       v               v               v               v         │
│  识别功能模块     拆解测试场景     转换为MCP操作    设计验证点     │
│  用户角色        正向/边界/异常    页面导航         UI状态验证     │
│  交互场景        优先级分配        元素操作         文本内容验证   │
│  数据流转        测试类型分类      等待策略         URL验证       │
│                                                                 │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                  │
│  │ 数据准备  │ -> │ 生成清单  │ -> │ 评审优化  │                  │
│  └──────────┘    └──────────┘    └──────────┘                  │
│       │               │               │                         │
│       v               v               v                         │
│  测试数据设计     输出Excel/YAML    团队评审                      │
│  环境配置        工具分配          可执行性验证                   │
│  前置条件        进度跟踪          持续优化                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 BDD 行为驱动设计

采用 **Given-When-Then** 模式描述测试场景：

```gherkin
Feature: 用户登录
  作为一个注册用户
  我希望能够登录系统
  以便访问个人资源

  Scenario: 正确凭证登录成功
    Given 用户在登录页面
    And 用户名输入框可见
    And 密码输入框可见
    When 用户输入正确的用户名 "testuser"
    And 用户输入正确的密码 "Test@123"
    And 用户点击登录按钮
    Then 页面跳转到首页
    And 显示欢迎信息 "欢迎, testuser"
    And 退出按钮可见
```

### 2.3 测试设计原则 (FIRST)

| 原则 | 说明 | 实践 |
|------|------|------|
| **F**ast | 快速执行 | 避免不必要的等待，使用条件等待 |
| **I**ndependent | 独立运行 | 用例间无依赖，可单独执行 |
| **R**epeatable | 可重复 | 相同条件下结果一致 |
| **S**elf-validating | 自验证 | 自动判断通过/失败 |
| **T**imely | 及时编写 | 与功能开发同步 |

---

## 3. 测试用例设计原则

### 3.1 优先级定义

| 优先级 | 标识 | 定义 | 覆盖范围 | 执行频率 |
|--------|------|------|----------|----------|
| **P0** | 阻塞性 | 核心业务流程，影响系统可用性 | 登录、支付、核心功能 | 每次构建 |
| **P1** | 高 | 主要功能，用户高频使用 | 主要业务功能 | 每日回归 |
| **P2** | 中 | 次要功能，有替代方案 | 辅助功能、边界场景 | 周度回归 |
| **P3** | 低 | 极少使用，UI 细节 | 极端场景、美化功能 | 版本发布前 |

### 3.2 测试类型分类

| 测试类型 | 目的 | 典型场景 | 推荐工具 |
|---------|------|---------|---------|
| **功能测试** | 验证功能正确性 | 登录、提交表单、数据展示 | Playwright |
| **表单测试** | 验证输入校验 | 必填项、格式校验、边界值 | Playwright |
| **边界测试** | 验证边界条件 | 空值、最大长度、特殊字符 | Playwright |
| **异常测试** | 验证错误处理 | 网络异常、超时、无权限 | Playwright |
| **安全测试** | 验证安全性 | XSS、CSRF、注入攻击 | Playwright |
| **性能测试** | 验证性能指标 | 页面加载、Core Web Vitals | Chrome DevTools |
| **网络验证** | 验证 API 交互 | 请求参数、响应数据 | Chrome DevTools |

### 3.3 用例粒度控制

**原则**：一个用例只验证一个业务场景

```yaml
# ✅ 好的粒度
用例1: 正确用户名密码登录成功
用例2: 错误密码登录失败
用例3: 空用户名提示必填

# ❌ 过粗的粒度
用例1: 登录功能测试（包含所有场景）

# ❌ 过细的粒度
用例1: 输入用户名
用例2: 输入密码
用例3: 点击登录按钮
```

---

## 4. 测试用例结构规范

### 4.1 Excel 格式（推荐）

采用**两工作表结构**：TestCases（用例概览）+ TestSteps（步骤明细），支持变量引用和数据驱动。

#### 工作表 1: TestCases（测试用例概览）

| 字段 | 必填 | 说明 | 示例 |
|------|------|------|------|
| 用例ID | ✅ | 唯一标识，格式 `TC-{模块}-{序号}` | TC-MSG-001 |
| 测试场景 | ✅ | 场景描述（一句话） | 首次发送消息自动创建会话 |
| 优先级 | ✅ | P0/P1/P2/P3 | P0 |
| 测试类型 | ✅ | 功能/表单/边界/异常/性能 | 功能测试 |
| 执行工具 | ✅ | Playwright / Chrome DevTools | Playwright |
| 测试URL | ✅ | 目标测试地址 | https://test.example.com |
| 登录凭证 | ⚠️ | JSON 格式登录信息 | {"username":"test_user","password":"Test@123"} |
| 业务数据 | ⚠️ | JSON 格式业务参数 | {"jobId":"job_12345","sessionId":"session_abc"} |
| 前置条件 | ✅ | 测试前提条件 | 已登录状态 |
| 预期结果 | ✅ | 最终期望结果 | 成功创建会话并返回sessionId |
| 执行状态 | - | 未执行/通过/失败/阻塞 | 未执行 |
| 备注 | - | 其他说明（如特殊配置） | AI模板ID=5003 |

**字段设计说明**：
- **登录凭证**：JSON 格式，支持 `${登录凭证.username}` 变量引用
- **业务数据**：JSON 格式，支持 `${业务数据.jobId}` 变量引用
- **执行工具**：明确指定工具，便于执行器选择

#### 工作表 2: TestSteps（测试步骤明细）

| 字段 | 必填 | 说明 | 示例 |
|------|------|------|------|
| 用例ID | ✅ | 关联用例 | TC-MSG-001 |
| 步骤序号 | ✅ | 步骤编号（整数） | 1 |
| 步骤描述 | ✅ | 人类可读的操作说明 | 打开登录页面 |
| MCP工具 | ✅ | MCP 工具名称 | browser_navigate |
| MCP参数JSON | ✅ | JSON 格式参数（支持变量引用） | {"url":"${testUrl}/login"} |
| 元素名称 | ⚠️ | 目标元素标识（用于定位） | 登录按钮 |
| 元素类型 | ⚠️ | UI 元素类型 | button / textbox / link |
| 预期结果 | ✅ | 步骤预期 | 页面加载 |
| 备注 | - | 补充说明 | 根据用例调整 |

**变量引用规范**：

```yaml
变量类型:
  环境变量:
    - ${testUrl}        # 测试URL，来自 TestCases.测试URL
    
  登录凭证变量:
    - ${登录凭证.username}   # 用户名
    - ${登录凭证.password}   # 密码
    
  业务数据变量:
    - ${业务数据.jobId}      # 岗位ID
    - ${业务数据.sessionId}  # 会话ID
    - ${业务数据.messageId}  # 消息ID
    
  运行时变量:
    - ${ref.username}   # 从快照获取的元素引用
    - ${ref.password}   # 动态获取的元素定位
```

#### 实际用例示例（消息交互场景）

**TestCases 工作表**：

| 用例ID | 测试场景 | 优先级 | 测试类型 | 执行工具 | 测试URL | 登录凭证 | 业务数据 | 前置条件 | 预期结果 |
|--------|---------|--------|---------|---------|---------|---------|---------|---------|---------|
| TC-MSG-001 | 首次发送消息自动创建会话 | P0 | 功能测试 | Playwright | https://test.example.com | {"username":"test_user","password":"Test@123"} | {"jobId":"job_12345"} | 已登录状态 | 成功创建会话并返回sessionId |
| TC-MSG-004 | 首条消息生成并触发AI推荐 | P0 | 功能测试 | Playwright | https://test.example.com | {"username":"test_user","password":"Test@123"} | {"jobId":"job_12345","aiTemplateId":5003} | 已登录，岗位有效 | 消息状态IN_PROGRESS，AI调用成功 |
| TC-MSG-010 | 消息流式输出接口-完成状态 | P1 | 功能测试 | Playwright | https://test.example.com | {"username":"test_user","password":"Test@123"} | {"messageId":"msg_001"} | 消息状态COMPLETED | 返回完整消息内容 |

**TestSteps 工作表**：

| 用例ID | 步骤序号 | 步骤描述 | MCP工具 | MCP参数JSON | 元素名称 | 元素类型 | 预期结果 |
|--------|---------|---------|---------|-------------|---------|---------|---------|
| TC-MSG-001 | 1 | 打开登录页面 | browser_navigate | {"url":"${testUrl}/login"} | - | - | 页面加载 |
| TC-MSG-001 | 2 | 获取页面快照 | browser_snapshot | {} | - | - | 获取元素ref |
| TC-MSG-001 | 3 | 填写登录表单 | browser_fill_form | {"fields":[{"ref":"${ref.username}","value":"${登录凭证.username}"},{"ref":"${ref.password}","value":"${登录凭证.password}"}]} | - | textbox | 登录成功 |
| TC-MSG-001 | 4 | 点击登录按钮 | browser_click | {"element":"登录按钮"} | 登录按钮 | button | 触发登录 |
| TC-MSG-001 | 5 | 等待登录成功 | browser_wait_for | {"text":"欢迎"} | - | - | 登录完成 |
| TC-MSG-001 | 6 | 执行测试操作 | browser_navigate | {"url":"${testUrl}/api/agent/..."} | - | - | 操作执行 |
| TC-MSG-001 | 7 | 获取结果快照 | browser_snapshot | {} | - | - | 捕获结果 |
| TC-MSG-001 | 8 | 验证预期结果 | browser_evaluate | {"expression":"..."} | - | - | 验证通过 |
| TC-MSG-001 | 9 | 截图记录 | browser_take_screenshot | {"fullPage":true} | - | - | 截图保存 |

### 4.2 标准步骤模板

大多数测试用例遵循以下标准步骤流程：

```yaml
标准9步流程:
  步骤1: 打开登录页面
    工具: browser_navigate
    参数: {"url":"${testUrl}/login"}
    
  步骤2: 获取页面快照
    工具: browser_snapshot
    参数: {}
    说明: 获取元素引用(ref)用于后续操作
    
  步骤3: 填写登录表单
    工具: browser_fill_form
    参数: {"fields":[...]}
    说明: 批量填写用户名密码
    
  步骤4: 点击登录按钮
    工具: browser_click
    参数: {"element":"登录按钮"}
    
  步骤5: 等待登录成功
    工具: browser_wait_for
    参数: {"text":"欢迎"}
    
  步骤6: 执行测试操作
    工具: browser_navigate / browser_click / browser_evaluate
    参数: 根据具体测试场景调整
    
  步骤7: 获取结果快照
    工具: browser_snapshot
    参数: {}
    
  步骤8: 验证预期结果
    工具: browser_evaluate
    参数: {"expression":"..."}
    说明: 执行断言验证
    
  步骤9: 截图记录
    工具: browser_take_screenshot
    参数: {"fullPage":true}
```

### 4.3 MCP 工具参考表

| 工具名 | 功能说明 | 参数示例 | 使用场景 |
|--------|---------|---------|---------|
| browser_navigate | 页面导航 | {"url":"https://..."} | 打开页面 |
| browser_snapshot | 获取页面快照 | {} | 获取元素 ref、验证页面状态 |
| browser_fill_form | 批量填写表单 | {"fields":[{"ref":"...","value":"..."}]} | 登录、表单提交 |
| browser_click | 点击元素 | {"element":"登录按钮"} | 按钮点击、链接点击 |
| browser_type | 输入文本 | {"element":"搜索框","text":"关键词"} | 单个输入框 |
| browser_wait_for | 等待条件 | {"text":"欢迎","timeout":5000} | 等待页面加载、异步操作 |
| browser_evaluate | 执行JS表达式 | {"expression":"document.title"} | 断言验证、数据提取 |
| browser_take_screenshot | 截图 | {"fullPage":true} | 记录测试结果 |
| browser_press_key | 键盘操作 | {"key":"Enter"} | 快捷键、导航键 |
| browser_hover | 鼠标悬停 | {"element":"菜单项"} | 触发悬停效果 |
| browser_drag | 拖拽操作 | {"source":"元素A","target":"元素B"} | 拖拽排序、移动 |

### 4.4 YAML 格式（替代方案）

```yaml
测试用例ID: TC-MSG-001
测试场景: 首次发送消息自动创建会话
优先级: P0
测试类型: 功能测试
执行工具: Playwright

环境配置:
  测试URL: https://test.example.com
  登录凭证:
    username: test_user
    password: Test@123
  业务数据:
    jobId: job_12345

前置条件:
  - 已登录状态
  - 岗位数据有效

测试步骤:
  步骤1:
    描述: 打开登录页面
    MCP工具: browser_navigate
    MCP参数: {"url":"${testUrl}/login"}
    预期结果: 页面加载

  步骤2:
    描述: 获取页面快照
    MCP工具: browser_snapshot
    MCP参数: {}
    预期结果: 获取元素ref

  步骤3:
    描述: 填写登录表单
    MCP工具: browser_fill_form
    MCP参数:
      fields:
        - ref: "${ref.username}"
          value: "${登录凭证.username}"
        - ref: "${ref.password}"
          value: "${登录凭证.password}"
    元素类型: textbox
    预期结果: 登录成功

  步骤4:
    描述: 点击登录按钮
    MCP工具: browser_click
    MCP参数: {"element":"登录按钮"}
    元素名称: 登录按钮
    元素类型: button
    预期结果: 触发登录

  步骤5:
    描述: 等待登录成功
    MCP工具: browser_wait_for
    MCP参数: {"text":"欢迎"}
    预期结果: 登录完成

  步骤6:
    描述: 执行测试-发送首条消息
    MCP工具: browser_navigate
    MCP参数: {"url":"${testUrl}/api/agent/send?jobId=${业务数据.jobId}"}
    预期结果: 操作执行

  步骤7:
    描述: 获取结果快照
    MCP工具: browser_snapshot
    MCP参数: {}
    预期结果: 捕获结果

  步骤8:
    描述: 验证预期结果
    MCP工具: browser_evaluate
    MCP参数: {"expression":"document.body.innerText.includes('sessionId')"}
    预期结果: 验证通过

  步骤9:
    描述: 截图记录
    MCP工具: browser_take_screenshot
    MCP参数: {"fullPage":true}
    预期结果: 截图保存

预期结果: 成功创建会话并返回sessionId
```

---

## 5. 测试场景分类与设计

### 5.1 正向流程（Happy Path）

**定义**：用户按预期操作，系统正常响应的场景

```yaml
设计要点:
  - 覆盖核心业务流程
  - 使用有效的测试数据
  - 验证成功状态和结果
  
示例场景:
  - 正确凭证登录成功
  - 表单完整填写提交成功
  - 商品添加购物车成功
  - 订单支付成功
```

### 5.2 边界值测试

**定义**：测试输入边界条件的场景

```yaml
边界类型:
  数值边界:
    - 最小值: 0, 1
    - 最大值: MAX_INT, 字段最大长度
    - 边界±1: min-1, min, min+1, max-1, max, max+1
    
  字符串边界:
    - 空字符串: ""
    - 单字符: "a"
    - 最大长度: 字段定义的最大长度
    - 超长字符串: 最大长度 + 1
    
  特殊字符:
    - 空格: " ", "  ", " test "
    - 特殊符号: !@#$%^&*()
    - Unicode: 中文、日文、emoji
    - SQL 注入字符: ' OR '1'='1
    - XSS 字符: <script>alert(1)</script>

示例用例:
  TC-FORM-BOUNDARY-001:
    场景: 用户名最小长度验证
    输入: "a"（1个字符）
    预期: 提示"用户名至少2个字符"
    
  TC-FORM-BOUNDARY-002:
    场景: 用户名最大长度验证
    输入: "a" * 21（21个字符）
    预期: 提示"用户名最多20个字符"
```

### 5.3 异常流程测试

**定义**：测试错误输入或异常情况的场景

```yaml
异常类型:
  输入异常:
    - 空输入
    - 格式错误
    - 类型错误
    
  业务异常:
    - 无权限操作
    - 数据不存在
    - 状态冲突
    
  系统异常:
    - 网络超时
    - 服务不可用
    - 并发冲突

示例用例:
  TC-LOGIN-ERROR-001:
    场景: 错误密码登录
    输入: 正确用户名 + 错误密码
    预期: 显示"用户名或密码错误"
    
  TC-LOGIN-ERROR-002:
    场景: 不存在用户登录
    输入: 不存在的用户名
    预期: 显示"用户不存在"或"用户名或密码错误"
```

### 5.4 场景矩阵设计

使用等价类划分和边界值分析组合测试场景：

| 用户名 | 密码 | 预期结果 | 优先级 |
|--------|------|---------|--------|
| 正确 | 正确 | 登录成功 | P0 |
| 正确 | 错误 | 登录失败，提示密码错误 | P0 |
| 错误 | 正确 | 登录失败，提示用户不存在 | P0 |
| 空 | 任意 | 提示用户名必填 | P1 |
| 任意 | 空 | 提示密码必填 | P1 |
| 空 | 空 | 提示用户名和密码必填 | P1 |
| 特殊字符 | 正确 | 登录失败或输入校验 | P2 |
| SQL注入 | 任意 | 登录失败，无安全漏洞 | P1 |

---

## 6. 元素定位策略

### 6.1 定位原则

```yaml
定位优先级（从高到低）:
  1. 语义化属性:
     - data-testid="login-button"
     - aria-label="登录"
     - role="button"
     
  2. 文本内容:
     - 按钮文本: "登录", "提交"
     - 链接文本: "忘记密码"
     
  3. 元素类型 + 属性:
     - textbox[placeholder="用户名"]
     - button[type="submit"]
     
  4. 层级关系:
     - form > input:first-child
     - .login-form .submit-btn

避免使用:
  - 动态生成的 ID: id="el_12345"
  - 样式类名: .btn-primary
  - 绝对路径: /html/body/div[1]/form/input[2]
```

### 6.2 动态元素处理

```yaml
动态 UID 处理策略:
  问题: 每次获取快照后，元素的 UID/ref 会变化
  
  解决方案:
    1. 操作前获取快照:
       - 每次操作前调用 take_snapshot
       - 从最新快照中查找目标元素
       
    2. 使用描述性定位:
       - 不硬编码 UID
       - 使用元素描述匹配: "登录按钮", "用户名输入框"
       
    3. 等待元素稳定:
       - 页面加载后等待
       - 动画完成后操作

示例:
  步骤1:
    描述: 获取页面元素
    MCP操作:
      工具: take_snapshot
      参数: {}
    说明: 从快照中找到"用户名"输入框的 UID
    
  步骤2:
    描述: 输入用户名
    MCP操作:
      工具: fill
      参数:
        uid: "{从步骤1快照中获取的用户名输入框 UID}"
        value: "testuser"
```

### 6.3 元素等待策略

```yaml
等待类型:
  显式等待（推荐）:
    - wait_for: {"text": "加载完成"}
    - wait_for: {"textGone": "加载中..."}
    
  条件等待:
    - 元素可见
    - 元素可交互
    - 文本出现/消失
    
  超时配置:
    - 默认超时: 5000ms
    - 长操作超时: 30000ms
    - 页面加载超时: 60000ms

避免:
  - 固定时间等待: sleep(3000)
  - 无限等待: 无超时设置
```

---

## 7. 断言设计策略

### 7.1 断言类型

| 断言类型 | 说明 | 示例 |
|---------|------|------|
| **元素存在** | 验证元素在页面上存在 | 登录按钮存在 |
| **元素可见** | 验证元素可见（非隐藏） | 错误提示可见 |
| **元素状态** | 验证元素属性状态 | 按钮 disabled=false |
| **文本内容** | 验证元素文本 | 标题包含"欢迎" |
| **URL 验证** | 验证页面 URL | URL 包含 "/dashboard" |
| **属性值** | 验证元素属性值 | input.value="testuser" |
| **数量验证** | 验证元素数量 | 列表项数量 >= 5 |

### 7.2 断言设计原则

```yaml
原则:
  1. 每个步骤至少一个断言
  2. 关键步骤多重断言
  3. 断言要具体明确
  4. 避免过度断言

示例:
  登录成功验证:
    主断言:
      - URL 包含 "/home" 或 "/dashboard"
    辅助断言:
      - 欢迎信息包含用户名
      - 退出按钮可见
      - 登录按钮不存在
      
  表单提交验证:
    主断言:
      - 成功提示出现
    辅助断言:
      - 表单重置或跳转
      - 数据正确保存（通过 API 验证）
```

### 7.3 断言失败处理

```yaml
失败处理策略:
  AssertionFailed:
    - 不重试（业务逻辑问题）
    - 截图保存现场
    - 记录详细错误信息
    - 继续执行后续用例
    
  输出信息:
    - 预期结果: "页面显示'欢迎, testuser'"
    - 实际结果: "页面显示'登录失败'"
    - 失败原因: 断言失败，业务逻辑问题
    - 修复建议: 检查登录功能实现
```

---

## 8. 测试数据管理

### 8.1 数据分类

| 数据类型 | 说明 | 管理方式 |
|---------|------|---------|
| **静态数据** | 固定不变的测试数据 | 配置文件、Excel |
| **动态数据** | 每次执行生成的数据 | 时间戳、随机数 |
| **环境数据** | 与环境相关的数据 | 环境变量、配置中心 |
| **敏感数据** | 密码、密钥等 | 加密存储、环境变量 |

### 8.2 数据准备策略

```yaml
数据准备原则:
  1. 测试数据独立:
     - 使用专用测试账号
     - 不依赖生产数据
     
  2. 数据可重复:
     - 每次执行前重置数据
     - 或使用唯一标识避免冲突
     
  3. 数据最小化:
     - 只准备必要的数据
     - 避免数据膨胀

数据准备方式:
  前置脚本:
    - 通过 API 创建测试数据
    - 数据库直接插入
    
  内置数据:
    - 使用预置的测试账号
    - 使用固定的测试数据集
    
  动态生成:
    - 时间戳: test_user_{timestamp}
    - UUID: test_{uuid}
```

### 8.3 数据清理策略

```yaml
清理时机:
  测试前清理:
    - 删除上次测试残留数据
    - 重置测试账号状态
    
  测试后清理:
    - 删除本次测试创建的数据
    - 恢复初始状态

清理方式:
  API 清理: 调用删除接口
  数据库清理: 执行清理 SQL
  自动过期: 设置数据过期时间
```

---

## 9. 工具选择策略

### 9.1 工具对比

| 维度 | Playwright | Chrome DevTools |
|------|------------|-----------------|
| **元素定位** | ref（人类可读描述） | uid（a11y tree） |
| **表单填写** | `browser_fill_form` 批量 | `fill` 单字段 |
| **等待机制** | 等待出现/消失/时间 | 仅等待文本出现 |
| **性能分析** | ❌ 不支持 | ✅ Core Web Vitals |
| **网络过滤** | 简单 | 详细（18种类型） |
| **代码执行** | `browser_run_code` 完整脚本 | `evaluate_script` |
| **浏览器管理** | 独立实例 | 连接已打开浏览器 |
| **跨浏览器** | ✅ 支持 | ❌ 仅 Chrome |

### 9.2 选择决策树

```
测试类型判断
│
├── 性能测试？
│   ├── 是 → Chrome DevTools（唯一支持 Core Web Vitals）
│   └── 否 → 继续判断
│
├── 网络请求详细验证？
│   ├── 是 → Chrome DevTools（过滤能力强）
│   └── 否 → 继续判断
│
├── 需要已登录状态/Cookie？
│   ├── 是 → Chrome DevTools（连接已打开浏览器）
│   └── 否 → 继续判断
│
├── 表单测试（多字段）？
│   ├── 是 → Playwright（browser_fill_form 批量填写）
│   └── 否 → 继续判断
│
├── 复杂交互流程？
│   ├── 是 → Playwright（browser_run_code 灵活）
│   └── 否 → 继续判断
│
└── 其他（功能测试等）
    └── Playwright（默认，自动化能力强）
```

### 9.3 工具分配规则

| 测试类型 | 执行工具 | 原因 |
|---------|---------|------|
| 功能测试 | **Playwright** | 自动化能力强，默认选择 |
| 表单测试 | **Playwright** | `browser_fill_form` 批量填写 |
| 安全测试 | **Playwright** | 自动化能力强 |
| 异常测试 | **Playwright** | 自动化能力强 |
| 边界测试 | **Playwright** | 自动化能力强 |
| 复杂交互 | **Playwright** | `browser_run_code` 灵活 |
| 性能测试 | **Chrome DevTools** | 唯一支持 Core Web Vitals |
| 网络请求详细验证 | **Chrome DevTools** | 过滤能力强（18种资源类型） |
| 需要已登录状态 | **Chrome DevTools** | 连接已打开浏览器 |

---

## 10. 测试执行流程

### 10.1 标准执行流程

```
┌─────────────────────────────────────────────────────────────────┐
│                      UI 自动化测试执行流程                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  步骤0: 检查输出目录（断点续执行判断）                              │
│         ↓                                                       │
│  步骤1: 读取和分析测试用例                                        │
│         ↓                                                       │
│  步骤2: 制定执行计划 + 生成进度文件                                │
│         ↓                                                       │
│  步骤3: 逐个执行测试用例（一次一个）                               │
│         ↓                                                       │
│  步骤4: 记录日志 + 更新进度文件                                   │
│         ↓                                                       │
│  步骤5: 循环执行下一个用例                                        │
│         ↓                                                       │
│  步骤6: 输出总结报告                                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 10.2 单用例执行流程

```yaml
用例执行流程:
  1. 准备阶段:
     - navigate_page: 打开目标页面
     - take_snapshot: 获取初始页面状态
     - 验证页面加载成功
     
  2. 操作阶段:
     - take_snapshot: 获取当前页面元素
     - fill/click 等: 执行用户操作
     - wait_for: 等待响应（如需要）
     - take_snapshot: 获取操作后状态
     
  3. 验证阶段:
     - take_snapshot: 获取最终页面状态
     - 对比快照: 验证预期结果
     - take_screenshot: 记录测试结果（可选）
     
  4. 清理阶段:
     - 恢复初始状态或清理测试数据
```

### 10.3 输出目录结构

```
test-output-{yyyyMMddHHmmss}/
├── progress.md          # 执行计划 + 进度清单
├── test.log             # 执行日志
├── report.md            # 测试报告（执行完成后生成）
└── screenshots/         # 截图目录
    ├── TC-LOGIN-001_final.png
    ├── TC-LOGIN-002_error.png
    └── ...
```

### 10.4 状态定义

| 状态 | 标记 | 含义 |
|------|------|------|
| 待测试 | ⏳ | 用例尚未执行 |
| 通过 | ✅ | 所有断言通过 |
| 未通过 | ❌ | 断言失败（业务问题） |
| 执行失败 | ⚠️ | 异常/错误（环境问题） |

---

## 11. 重试与容错机制

### 11.1 重试配置

```yaml
默认配置:
  stepRetry: 2              # 步骤失败重试次数
  caseRetry: 1              # 用例失败重试次数
  retryDelay: 1000          # 重试间隔（毫秒）
```

### 11.2 错误分类与重试策略

| 错误类型 | 描述 | 可重试 | 处理建议 |
|---------|------|--------|---------|
| `ElementNotFound` | 元素未找到 | ✅ 是 | 刷新快照后重试 |
| `ElementNotInteractable` | 元素不可交互 | ✅ 是 | 等待后重试 |
| `Timeout` | 操作超时 | ✅ 是 | 增加等待时间重试 |
| `NetworkError` | 网络错误 | ✅ 是 | 等待网络恢复重试 |
| `AssertionFailed` | 断言失败 | ❌ 否 | 业务问题，需修复代码 |
| `NavigationFailed` | 导航失败 | ❌ 否 | URL 错误，需修复配置 |

### 11.3 步骤级重试流程

```
步骤执行失败
│
├── 错误类型是否可重试？
│   ├── 否 → 标记失败，记录日志
│   └── 是 → 检查重试次数
│
├── 重试次数 < stepRetry？
│   ├── 否 → 标记失败，记录日志
│   └── 是 → 执行重试
│
└── 执行重试
    ├── 记录重试日志: [RETRY]
    ├── 等待 retryDelay 毫秒
    ├── 刷新页面快照
    └── 重新执行步骤操作
```

### 11.4 用例级重试流程

```
用例执行失败
│
├── 失败原因是否可重试？
│   ├── AssertionFailed → 不重试（业务问题）
│   └── 其他可重试错误 → 检查重试次数
│
├── 重试次数 < caseRetry？
│   ├── 否 → 标记用例失败
│   └── 是 → 执行用例重试
│
└── 执行用例重试
    ├── 记录日志: [CASE_RETRY]
    ├── 等待 retryDelay 毫秒
    ├── 重新导航到初始页面
    └── 从步骤1重新执行整个用例
```

---

## 12. 测试报告规范

### 12.1 报告内容结构

```
测试报告
├── 基本信息
│   ├── 执行时间范围
│   ├── 测试环境
│   ├── 目标 URL
│   └── 执行工具统计
│
├── 测试统计
│   ├── 总体结果（通过率）
│   ├── 按优先级统计
│   └── 按测试类型统计
│
├── 详细结果
│   ├── 通过的测试用例
│   ├── 未通过的测试用例（含详情）
│   └── 执行失败的测试用例
│
├── 问题汇总
│   ├── 高优先级问题
│   └── 中低优先级问题
│
└── 总结
    ├── 测试结论
    ├── 风险评估
    └── 后续建议
```

### 12.2 报告模板

```markdown
# UI 自动化测试报告

## 📋 基本信息

| 项目 | 内容 |
|------|------|
| 执行时间 | 2024-12-24 10:30:00 ~ 10:45:00 |
| 测试环境 | Chrome 120 / macOS |
| 目标 URL | http://example.com |
| 执行工具 | Playwright (8), Chrome DevTools (2) |
| 总耗时 | 15分钟 |

## 📊 测试统计

### 总体结果

| 指标 | 数值 | 百分比 |
|------|------|--------|
| 总用例数 | 10 | 100% |
| ✅ 通过 | 8 | 80% |
| ❌ 未通过 | 1 | 10% |
| ⚠️ 执行失败 | 1 | 10% |

### 按优先级统计

| 优先级 | 总数 | 通过 | 未通过 | 执行失败 | 通过率 |
|--------|------|------|--------|----------|--------|
| P0-阻塞性 | 3 | 3 | 0 | 0 | 100% |
| P1-高 | 4 | 3 | 1 | 0 | 75% |
| P2-中 | 2 | 1 | 0 | 1 | 50% |
| P3-低 | 1 | 1 | 0 | 0 | 100% |

## ❌ 未通过的测试用例

### TC-LOGIN-002: 错误密码登录

| 项目 | 内容 |
|------|------|
| 优先级 | P1 |
| 测试类型 | 功能测试 |
| 失败步骤 | 步骤6: 验证错误提示 |

**失败原因**:
```
预期: "密码错误"
实际: "登录失败"
```

**修复建议**: 检查错误提示文案是否符合预期

## 📝 总结

### 测试结论
⚠️ 部分通过 - P0 用例全部通过，存在 P1 级别问题需关注

### 风险评估
🟡 中等风险 - 核心功能正常，但存在用户体验问题

### 后续建议
1. 立即修复: 无
2. 尽快修复: TC-LOGIN-002 错误提示文案
3. 计划修复: TC-PERF-001 执行环境问题
```

### 12.3 结论生成规则

```yaml
整体评估:
  全部通过: "✅ 全部通过"
  P0全部通过 && 通过率>=80%: "⚠️ 部分通过"
  P0有失败: "❌ 存在阻塞问题"
  通过率<50%: "❌ 大量失败"

风险等级:
  全部通过: "🟢 低"
  P0全部通过 && P1通过率>=80%: "🟡 中等"
  P0有失败 || P1通过率<50%: "🔴 高"
```

---

## 13. 最佳实践与反模式

### 13.1 最佳实践

#### 用例设计

```yaml
✅ 推荐做法:
  - 一个用例只验证一个业务场景
  - 使用描述性的用例名称
  - 明确的前置条件和预期结果
  - 测试数据与用例分离
  - 使用语义化的元素定位
  
示例:
  用例名称: "TC-LOGIN-001: 正确用户名密码登录成功"
  前置条件: "用户未登录，在登录页面"
  预期结果: "成功跳转到首页，显示用户名"
```

#### 元素定位

```yaml
✅ 推荐做法:
  - 优先使用 data-testid
  - 使用语义化描述
  - 避免依赖样式类名
  - 每次操作前获取最新快照
  
示例:
  好的定位: data-testid="login-button"
  好的定位: 文本为"登录"的按钮
  避免: .btn-primary
  避免: /html/body/div[1]/button
```

#### 等待策略

```yaml
✅ 推荐做法:
  - 使用条件等待而非固定等待
  - 设置合理的超时时间
  - 等待关键元素出现再操作
  
示例:
  好的等待: wait_for(text="加载完成")
  好的等待: wait_for(element_visible=true)
  避免: sleep(3000)
```

#### 断言设计

```yaml
✅ 推荐做法:
  - 每个步骤至少一个断言
  - 断言要具体明确
  - 使用多重断言验证关键结果
  
示例:
  主断言: URL 包含 "/dashboard"
  辅助断言: 欢迎信息包含用户名
  辅助断言: 退出按钮可见
```

### 13.2 反模式

#### 用例设计反模式

```yaml
❌ 避免做法:
  - 一个用例包含多个场景
  - 用例之间有依赖关系
  - 硬编码测试数据
  - 模糊的预期结果
  
反例:
  用例名称: "登录功能测试"（太笼统）
  预期结果: "登录成功"（不够具体）
  依赖: "需要先执行 TC-001"（用例不独立）
```

#### 元素定位反模式

```yaml
❌ 避免做法:
  - 使用动态生成的 ID
  - 使用样式类名定位
  - 使用绝对 XPath
  - 硬编码 UID/ref
  
反例:
  id="el_12345"（动态 ID）
  .btn-primary（样式类名）
  /html/body/div[1]/form/input[2]（绝对路径）
  uid="2_9"（硬编码，会变化）
```

#### 等待策略反模式

```yaml
❌ 避免做法:
  - 固定时间等待
  - 无超时设置
  - 过短的超时时间
  
反例:
  sleep(5000)（固定等待）
  wait_for(text="xxx")（无超时）
  timeout=100（过短）
```

#### 断言设计反模式

```yaml
❌ 避免做法:
  - 无断言的测试步骤
  - 过于宽泛的断言
  - 过度断言（验证不相关内容）
  
反例:
  无断言: 只执行操作，不验证结果
  宽泛断言: "页面有内容"
  过度断言: 验证页面所有元素的样式
```

---

## 附录

### A. 常用 MCP 工具速查表

#### Playwright MCP 工具

| 工具 | 功能 | 参数示例 | 使用场景 |
|------|------|---------|---------|
| browser_navigate | 页面导航 | {"url":"https://..."} | 打开页面、跳转 |
| browser_snapshot | 获取快照 | {} | 获取元素 ref、验证状态 |
| browser_click | 点击元素 | {"element":"登录按钮"} | 按钮、链接点击 |
| browser_type | 输入文本 | {"element":"搜索框","text":"关键词"} | 单个输入框 |
| browser_fill_form | 批量填写 | {"fields":[{"ref":"...","value":"..."}]} | 登录、表单 |
| browser_wait_for | 等待条件 | {"text":"欢迎","timeout":5000} | 等待加载、异步操作 |
| browser_evaluate | 执行JS | {"expression":"document.title"} | 断言、数据提取 |
| browser_take_screenshot | 截图 | {"fullPage":true} | 记录结果 |
| browser_press_key | 键盘操作 | {"key":"Enter"} | 快捷键、导航键 |
| browser_hover | 鼠标悬停 | {"element":"菜单项"} | 触发悬停效果 |
| browser_drag | 拖拽操作 | {"source":"A","target":"B"} | 拖拽排序 |
| browser_select_option | 下拉选择 | {"element":"选择框","value":"选项1"} | 下拉菜单 |
| browser_tabs | 标签页管理 | {"action":"new"} | 多标签页操作 |

#### Chrome DevTools MCP 工具

| 工具 | 功能 | 参数示例 | 使用场景 |
|------|------|---------|---------|
| navigate_page | 页面导航 | {"url":"https://..."} | 打开页面 |
| take_snapshot | 获取快照 | {} | 获取元素 uid |
| click | 点击元素 | {"uid":"2_11"} | 按钮点击 |
| fill | 填写输入框 | {"uid":"2_9","value":"text"} | 表单输入 |
| wait_for | 等待条件 | {"text":"欢迎"} | 等待文本出现 |
| evaluate_script | 执行JS | {"expression":"..."} | 断言验证 |
| take_screenshot | 截图 | {"fullPage":true} | 记录结果 |
| press_key | 键盘操作 | {"key":"Enter"} | 快捷键 |
| hover | 鼠标悬停 | {"uid":"2_5"} | 悬停效果 |
| drag | 拖拽操作 | {"sourceUid":"2_1","targetUid":"2_2"} | 拖拽 |
| performance_start_trace | 性能追踪 | {} | Core Web Vitals |
| performance_stop_trace | 停止追踪 | {} | 获取性能数据 |
| list_network_requests | 网络请求 | {} | 请求监控 |
| get_network_request | 请求详情 | {"reqid":"..."} | 请求验证 |

### B. 检查清单

#### 用例设计检查

- [ ] 用例 ID 唯一且符合命名规范
- [ ] 测试场景描述清晰
- [ ] 优先级和测试类型正确
- [ ] 前置条件明确
- [ ] 测试步骤完整
- [ ] 每个步骤有预期结果
- [ ] 关键步骤有验证点
- [ ] 测试数据准备就绪

#### 执行前检查

- [ ] 测试环境可用
- [ ] 目标 URL 可访问
- [ ] MCP 服务正常
- [ ] 测试数据已准备
- [ ] 输出目录已创建

#### 执行后检查

- [ ] 所有用例已执行
- [ ] 进度文件已更新
- [ ] 测试报告已生成
- [ ] 截图已保存
- [ ] 日志完整

### C. 版本历史

| 版本 | 日期 | 变更说明 |
|------|------|---------|
| 1.1.0 | 2024-12-24 | 更新测试用例结构规范：简化为两工作表结构（TestCases + TestSteps），新增变量引用规范、标准9步流程模板，基于消息交互实际用例优化 |
| 1.0.0 | 2024-12-24 | 初始版本，整合 ui-testcase-designer 和 ui-testcase-executor 技能 |

---

**文档维护**: 本文档应随着测试实践的积累持续更新和优化。
