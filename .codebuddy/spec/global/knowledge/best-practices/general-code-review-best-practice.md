# 代码审查通用最佳实践(AI代码生成指南)

---

**文档版本**：2.1 (AI生成增强版)  
**最后更新**：2025-12-05  
**作者**：johnsonyang  
**适用范围**：团队代码审查标准化 + 新员工培训 + 代码质量体系建立 + AI辅助审查  
**核心目标**：指导AI精准执行代码审查（五维度量化评估体系）  
**涵盖技术栈**：Java 8/17、Vue 2.x/3.x、通用最佳实践  

**适用场景**：
- ✅ 团队代码审查标准化：遵循审查框架和审查流程章节
- ✅ 新员工培训：遵循核心原则和五维度详解章节
- ✅ AI辅助审查：遵循技术栈专项标准和审查报告模板章节

**AI使用指南**：
1. **生成前**：阅读核心原则章节了解三大基石
2. **生成中**：遵循五维度详解的审查标准
3. **生成后**：执行审查报告模板生成结构化报告
4. **质量验证**：使用问题分类与优先级进行分级处理

---

## 📑 目录

- [核心原则](#核心原则)
- [审查框架](#审查框架)
- [审查流程](#审查流程)
- [五维度详解](#五维度详解)
- [技术栈专项标准](#技术栈专项标准)
- [审查深度指南](#审查深度指南)
- [问题分类与优先级](#问题分类与优先级)
- [审查报告模板](#审查报告模板)
- [实施建议](#实施建议)
- [常见误区](#常见误区)

---

## 核心原则

代码审查的根本目标是**提升代码质量**、**降低风险**、**促进知识分享**。

### 三大基石

1. **标准化**: 基于统一的审查标准执行，确保结果一致性
2. **量化**: 使用权重化评分体系，客观评估代码质量
3. **可执行**: 每个问题都配有具体改进建议，审查结果可立即执行

---

## 审查框架

### 五大维度

```
┌─────────────────────────────────────────────────────┐
│          代码审查五维度评估框架                        │
├─────────────────────────────────────────────────────┤
│ 编码规范      │ 架构设计      │ 安全防护              │
│ (代码质量)    │ (系统设计)    │ (风险控制)            │
│               │               │                     │
│ 30%           │ 20%           │ 20%                 │
└─────────────────────────────────────────────────────┘
        ↓                       ↓
    综合评分 = 加权计算各维度得分
    
├─────────────────────────────────────────────────────┤
│ 性能优化      │ 可维护性                              │
│ (运行效率)    │ (长期维护)                            │
│               │                                     │
│ 15%           │ 15%                                 │
└─────────────────────────────────────────────────────┘
```

### 权重化评分体系

| 维度 | 权重 | 关键指标 | 评分区间 |
|------|------|---------|---------|
| 编码规范 | 30% | 命名、格式、注释、常量 | 0-100 |
| 架构设计 | 20% | 职责划分、依赖、接口 | 0-100 |
| 安全防护 | 20% | 输入验证、权限、数据保护 | 0-100 |
| 性能优化 | 15% | 缓存、查询、异步 | 0-100 |
| 可维护性 | 15% | 复杂度、异常、测试 | 0-100 |

**单维度量化标准**

- **编码规范**
  - ≥90：无 P0/P1 规范问题，P2 ≤ 2 个，格式检查全部通过
  - 70–89：存在 ≤2 个 P1 或 ≤5 个 P2，自动化检查通过但需局部整改
  - 50–69：存在 ≥3 个 P1 或 ≥1 个 P0，需要集中整改
  - <50：规范体系缺失或大量 P0/P1 问题，需重新提测后再审
- **架构设计**
  - ≥90：服务边界清晰，无循环依赖，接口契约完备且有 ADR/设计说明
  - 70–89：结构基本合理，偶有跨层依赖或文档缺失但可快速修复
  - 50–69：出现架构异味（如职责混杂、依赖反转），需重构计划
  - <50：架构不可接受（如单体巨石、严重耦合），必须拒绝合并
- **安全防护**
  - ≥90：无 P0/P1 安全缺陷，输入验证、日志脱敏、权限链条齐备
  - 70–89：存在 ≤1 个 P1 安全问题且有明确补救方案
  - 50–69：存在多个 P1 或单个 P0 安全缺陷，需阻断上线
  - <50：安全机制缺失或数据暴露风险高，需启动安全评审
- **性能优化**
  - ≥90：关键路径经压测验证，无 N+1/慢查询，缓存/异步策略完备
  - 70–89：存在轻微性能隐患（可在 1 个迭代内消除）
  - 50–69：指标不达标或缺少监控，需要专项优化
  - <50：性能问题会阻断业务，如 OOM、雪崩风险，必须回退
- **可维护性**
  - ≥90：复杂度指标达标（方法 <100 行、圈复杂度 <10），关键逻辑具备 ≥80% 测试覆盖
  - 70–89：整体可维护，局部存在过长方法或测试缺口
  - 50–69：出现大量难以理解的代码或异常处理缺失
  - <50：缺乏测试与日志，导致无法交付维护

**综合得分等级**:
- A级: 85-100 (优秀)
- B级: 70-84 (良好)
- C级: 60-69 (中等)
- D级: <60 (需改进)

### 判分示例

#### 示例 1：中型 BFF 模块（良好水平，A级）

> 场景：400 行代码，涉及缓存与安全改动

| 维度 | 得分 | 量化依据 |
|------|------|----------|
| 编码规范 | 88 | 发现 1 个 P1（缺少 DTO 注释）与 2 个 P2（魔法值），自动化检查通过 |
| 架构设计 | 92 | 新增缓存层与 Service 解耦，有 ADR 记录，无跨层依赖 |
| 安全防护 | 78 | JWT 续期逻辑完备，但登录审计日志缺失（1 个 P1） |
| 性能优化 | 85 | 命中率监控完善，仍存在 1 个可优化的批量查询 |
| 可维护性 | 80 | 圈复杂度 8，新增单元测试覆盖 76%，仍需补齐异常路径 |

> **综合评分**：88×0.3 + 92×0.2 + 78×0.2 + 85×0.15 + 80×0.15 = **84.15（B级）**  
> **结论**：建议附带整改清单后允许合并

**整改建议**:
- P0: 无
- P1: 补充登录审计日志、补充 DTO 文档注释
- P2: 提取 3 个魔法值为常量、优化批量查询

---

#### 示例 2：小型 UI 组件（需改进，C级）

> 场景：Vue 3 新增表单组件，100 行代码

| 维度 | 得分 | 量化依据 |
|------|------|----------|
| 编码规范 | 65 | 缺少 JSDoc，存在 3 个 P1（变量命名模糊：`v`、`d`、`t`）与 2 个 P2 |
| 架构设计 | 72 | Props 校验不完整（缺 required 标记），Emit 类型未定义 |
| 安全防护 | 80 | 无 XSS 风险，v-html 正确使用了 DOMPurify |
| 性能优化 | 88 | 组件无不必要渲染，使用 v-memo 优化列表 |
| 可维护性 | 70 | 圈复杂度 9 略高，测试覆盖率 55%（P2） |

> **综合评分**：65×0.3 + 72×0.2 + 80×0.2 + 88×0.15 + 70×0.15 = **72.1（B级）**  
> **结论**：需要整改后重新审查

**阻塞项（P1）**:
- 变量命名规范化（v → value，d → disabled，t → type）
- Props 验证补完

**可后续改进（P2）**:
- 补充 JSDoc
- 提升测试覆盖率至 ≥75%

---

#### 示例 3：数据层查询优化（有安全隐患，D级）

> 场景：Java 订单查询接口，200 行代码

| 维度 | 得分 | 量化依据 |
|------|------|----------|
| 编码规范 | 75 | 基本规范达标，仅 1 个 P2（缺少异常说明的 throws 声明） |
| 架构设计 | 80 | 层次清晰，使用 Repository 模式 |
| 安全防护 | 35 | 🔴 **P0: SQL 注入**（使用 `"where id=" + id` 拼接），缺少输入验证 |
| 性能优化 | 60 | N+1 查询，缺少缓存 |
| 可维护性 | 65 | 方法 65 行，圈复杂度 11，异常处理不完整 |

> **综合评分**：75×0.3 + 80×0.2 + 35×0.2 + 60×0.15 + 65×0.15 = **61.25（C级）**  
> **结论**：🔴 **必须拒绝合并**，存在关键安全缺陷

**必修项（修复后重新审查）**:
- **SQL 注入修复**：改用参数化查询 (`?` 占位符 + 参数列表)
- **输入验证**：添加 `@NotNull @Min(1) Long id` 验证注解

**建议整改（可同步进行）**:
- 缓存订单查询结果（Redis，TTL 30min）
- 拆分 N+1 问题：批量加载相关数据
- 方法拆分：将 65 行分解为 3-4 个职责明确的方法

---

#### 示例 4：复杂业务流程（优秀，A级）

> 场景：转账核心业务逻辑，500 行代码（含单测）

| 维度 | 得分 | 量化依据 |
|------|------|----------|
| 编码规范 | 95 | 零 P0/P1，仅 1 个 P2（建议用常量替代魔法数字），自动化检查全通过 |
| 架构设计 | 95 | Service/Repository 分离清晰，事务边界明确，设计文档完备 |
| 安全防护 | 90 | 金额参数验证完整，操作日志完整（含用户 ID、时间、IP），幂等性保证（防重复提交） |
| 性能优化 | 92 | 主从库分离，缓存命中率 98%，支持异步通知 |
| 可维护性 | 96 | 方法 <40 行，圈复杂度 7，测试覆盖率 92%，包含边界测试和异常测试 |

> **综合评分**：95×0.3 + 95×0.2 + 90×0.2 + 92×0.15 + 96×0.15 = **93.7（A级）**  
> **结论**：✅ **直接允许合并**，推荐为同类代码样板

**可选优化（下一迭代）**:
- 补充性能压测报告（通过时间确认 <100ms）
- 收集性能指标（缓存命中率、P95 响应时间）

---

## 审查流程

### 三级审查体系

#### 基础审查 (15-30分钟)

用于快速验收，检查最常见的问题。

**检查清单**:
- ✓ 代码能否编译/运行通过
- ✓ 符合基本编码规范（命名、格式、注释）
- ✓ 关键类型已定义（TypeScript/Java 类型）
- ✓ 职责单一、文件大小合理

**适用场景**: 小改动、hotfix、快速迭代

---

#### 标准审查 (45-60分钟)

涵盖所有关键维度的完整审查。

**检查内容** (包含基础审查 +):
- 响应式系统/依赖管理是否正确
- 性能关键路径是否优化
- 安全风险是否识别
- 主要流程是否覆盖测试

**适用场景**: 常规功能开发、代码合并、PR Review

---

#### 专业审查 (2-3小时)

深度审查，包括设计评估和性能分析。

**检查内容** (包含标准审查 +):
- 系统架构是否合理
- 代码设计是否可扩展
- 测试覆盖率是否充分 (≥80%)
- 性能基准是否达标

**适用场景**: 核心模块开发、大功能特性、架构重构

---

### 审查执行步骤

```
1. 准备阶段
   ├─ 明确审查范围和级别
   ├─ 准备审查工具和清单
   └─ 了解业务背景和设计思路

2. 执行阶段
   ├─ 编码规范审查
   ├─ 架构设计审查
   ├─ 安全防护审查
   ├─ 性能优化审查
   └─ 可维护性审查

3. 评分阶段
   ├─ 计算各维度得分
   ├─ 计算综合得分
   └─ 确定改进等级 (A/B/C/D)

4. 报告阶段
   ├─ 生成问题清单 (按优先级排序)
   ├─ 提供具体改进建议
   ├─ 明确改进时间要求
   └─ 输出审查报告

5. 跟踪阶段
   ├─ 跟踪问题修复进度
   ├─ 验证修复质量
   └─ 持续反馈优化
```

---

## 五维度详解

### 1. 编码规范 (30%)

**目标**: 确保代码可读、可维护、符合项目标准

#### 核心要素

**命名规范** (30%)
- 类名: PascalCase (UserController、OrderService)
- 方法/变量: camelCase (getUserById、userName)
- 常量: UPPER_SNAKE_CASE (MAX_RETRY_COUNT、API_TIMEOUT)
- 布尔变量: is/has/can 开头 (isActive、hasPermission)
- 集合变量: 复数或 List/Map 结尾 (users、itemList)

**代码格式** (25%)
- 缩进: 4个空格 (不使用Tab)
- 行长: 不超过120字符
- 大括号: K&R风格 (左括号不换行)
- 空行: 逻辑块间适当分隔
- import: 按字母序排列，无冗余

**注释完整性** (25%)
- 公开类/方法必须有文档注释
- 文档注释包含 @param/@return/@throws
- 复杂逻辑有行内注释说明**为什么**而非**做什么**
- 无过期或错误的注释
- 无被注释掉的代码

**常量使用** (20%)
- 魔法数字使用常量替代 (状态码、业务规则)
- 魔法字符串使用常量 (错误消息、配置项)
- 常量位置合理 (类常量或枚举)
- 常量有清晰的文档说明

#### 常见问题模式

```
❌ 问题: 代码重复、命名模糊
✅ 方案: 提取方法、规范命名

❌ 问题: 缺少关键方法注释
✅ 方案: 添加 JavaDoc/JSDoc

❌ 问题: 魔法值遍布代码
✅ 方案: 定义常量，统一管理
```

---

### 2. 架构设计 (20%)

**目标**: 确保系统结构清晰、职责明确、易于扩展

#### 核心要素

**职责划分** (40%)
- 单一职责原则: 每个类/模块只有一个变化理由
- 合理的服务粒度: 不过大也不过小
- 高内聚低耦合: 逻辑相关的放一起，跨域依赖最少化
- 避免循环依赖: 清晰的依赖方向

**依赖管理** (30%)
- 正确的依赖流向: Controller → Service → Repository
- 使用依赖注入 (避免 new 创建对象)
- 优先构造器注入 (而非字段注入)
- 清晰的对象生命周期管理

**接口设计** (30%)
- RESTful 规范: 使用名词、HTTP方法语义正确
- 统一的响应格式: 统一的 ApiResponse 结构
- 完整的参数验证: @Valid/@Validated
- 清晰的错误码: 对应具体的业务异常
- API 文档完整: 支持 OpenAPI/Swagger 规范

#### 常见问题模式

```
❌ 问题: 职责混乱、Service 包含 UI 逻辑
✅ 方案: 明确层次划分，Business Logic 独立

❌ 问题: 循环依赖、复杂的依赖图
✅ 方案: 提取公共模块，使用工厂模式解耦

❌ 问题: API 设计不规范、缺少文档
✅ 方案: 遵循 RESTful，补充 OpenAPI 规范
```

---

### 3. 安全防护 (20%)

**目标**: 识别安全风险，防护常见攻击

#### 核心要素

**输入验证** (30%)
- 所有输入必须验证 (使用验证注解)
- 长度限制 (@Size/@Length)
- 格式验证 (@Pattern/@Email/@Phone)
- 范围限制 (@Min/@Max)
- 业务规则验证 (自定义验证器)

**权限控制** (25%)
- 敏感接口有权限检查 (@PreAuthorize)
- 细粒度权限 (功能级、数据级、接口级)
- Token 管理完善 (有效期、刷新机制)
- 密码加密存储 (BCrypt强度≥10)

**数据保护** (25%)
- 敏感数据加密存储 (密码、身份证号)
- 响应脱敏处理 (手机号、邮箱、身份证)
- SQL 注入防护 (参数化查询、不拼接SQL)
- 日志脱敏 (不记录敏感信息)

**日志安全** (20%)
- 关键操作记录日志 (登录、修改、删除)
- 异常包含堆栈信息 (便于调试)
- 日志包含用户标识 (用户ID/IP)
- 日志级别合理 (INFO/WARN/ERROR)

#### 常见问题模式

```
❌ 问题: 缺少输入验证，SQL 注入风险
✅ 方案: 使用验证框架，参数化查询

❌ 问题: 响应返回密码、身份证号
✅ 方案: 过滤敏感字段，脱敏处理

❌ 问题: 日志输出密钥、Token
✅ 方案: 日志脱敏，隐藏敏感信息
```

---

### 4. 性能优化 (15%)

**目标**: 识别性能瓶颈，提出优化方案

#### 核心要素

**查询优化** (35%)
- 避免 N+1 查询 (使用批量查询或联表)
- 明确指定字段 (避免 SELECT *)
- 分页合理 (有索引支持、有总数统计)
- 复杂查询有索引 (WHERE/JOIN/ORDER BY)

**缓存策略** (25%)
- 热点数据使用缓存 (Redis)
- 缓存 Key 有命名空间和过期时间
- 缓存更新策略明确 (主动更新或过期删除)
- 防护缓存穿透/雪崩/击穿

**异步处理** (20%)
- 耗时操作异步化 (@Async、消息队列)
- 异步任务有异常处理和重试机制
- 异步任务有监控和告警

**资源管理** (20%)
- 数据库连接及时释放 (连接池)
- 文件流及时关闭 (try-with-resources)
- 避免内存泄漏 (及时解除引用)
- 线程池使用合理 (自定义参数)

#### 常见问题模式

```
❌ 问题: 循环查询数据库，N+1 问题
✅ 方案: 使用批量查询或 IN 子句

❌ 问题: 每次请求都查询数据库，无缓存
✅ 方案: Redis 缓存热点数据

❌ 问题: 大数据同步处理，接口响应慢
✅ 方案: 异步处理，消息队列解耦
```

---

### 5. 可维护性 (15%)

**目标**: 确保代码易于理解、测试、修改

#### 核心要素

**代码复杂度** (25%)
- 方法长度 <100行 (超长方法难理解)
- 圈复杂度 <10 (分支逻辑过多)
- 嵌套层级 <3 (过深难追踪)
- 参数个数 <5 (参数过多难维护)
- 复杂逻辑已提取方法

**异常处理** (25%)
- 不捕获并吞掉异常 (至少记录日志)
- 不抛出 Exception (使用具体异常)
- 业务异常继承 RuntimeException
- 异常消息清晰 (便于定位问题)
- 使用全局异常处理器

**测试覆盖** (25%)
- 关键业务逻辑有单元测试
- 测试覆盖率 ≥70% (优秀 ≥80%)
- 边界条件有测试用例
- 异常场景有测试用例
- 测试独立可重复运行

**代码文档** (25%)
- 复杂逻辑有说明文档
- 设计决策有记录 (为什么选择这个方案)
- 架构图/流程图清晰
- 易用示例代码

#### 常见问题模式

```
❌ 问题: 方法过长(>100行)、嵌套过深(>5层)
✅ 方案: 拆分为多个小方法

❌ 问题: 捕获异常不处理，吞掉堆栈信息
✅ 方案: 记录异常日志，或重新抛出

❌ 问题: 缺少测试，难以验证功能
✅ 方案: 补充单元测试和集成测试

❌ 问题: 代码无注释，设计意图不清晰
✅ 方案: 补充文档和设计说明
```

---

## 技术栈专项标准

### Java 体系

> 在 `pom.xml`/`build.gradle` 中确认 `maven.compiler.source`、`java.version` 等配置，并在审查记录中显式注明项目 Java 版本，所有建议遵循"**不高于目标版本**"的原则。

#### Java 8 审查要点

1. **函数式特性落地**: 核查 Lambda/Stream 是否替代冗长 for-loop，注意流终止操作与短路条件，避免在 Stream 中抛受检异常。
2. **Optional 与空指针防护**: 禁止返回 null Optional；链式 `map/flatMap/orElseThrow` 必须有默认值或异常说明。
3. **日期时间 API 迁移**: 审查是否仍依赖 `java.util.Date`/`SimpleDateFormat`，必要时迁移到 `java.time` 并使用线程安全的 `DateTimeFormatter`。
4. **并发与 CompletableFuture**: 校验异步调用是否使用 `CompletableFuture` 配合线程池，确保 `join()` 前有异常处理。
5. **接口默认方法**: 当接口新增默认实现时，评估是否会破坏旧实现的业务假设。

#### Java 17 审查要点

1. **现代语法收敛**: 检查 `record`、`sealed class`、`pattern matching for instanceof`、`switch expression` 是否在合适场景使用，并验证生成的 bytecode 未触发旧框架限制。
2. **Text Block 与国际化**: 多行字符串必须配合 `String#formatted` 或模板变量，避免硬编码 SQL/JSON 时遗漏转义。
3. **模块化与封装**: 如使用 JPMS，确认 `module-info.java` 合理导出/开放包，避免暴露内部实现；Spring Boot 项目若未开启模块化，应避免随意引入 `requires java.desktop` 等多余模块。
4. **性能与 G1 配置**: Java 17 默认 G1，审查 `-XX` 参数是否与 LTS 配置冲突，并验证 `Record`/`sealed` 未造成序列化工具不兼容。
5. **升级建议**: 仍在 Java 8/11 长期支撑但具备升级条件的项目，应在报告中增加"可在下一迭代评估现有依赖对 Java 17 兼容性"。

#### Java 日志打印规范

**日志框架**

使用 SLF4J + Logback，通过 `@Slf4j` 注解或 `LoggerFactory.getLogger()` 获取 Logger。禁止 `System.out/err`。

**日志级别选择**

```java
// ERROR：系统错误、必须人工介入
log.error("支付失败，订单号: {}", orderId, e);

// WARN：降级处理、可恢复异常
log.warn("缓存失效降级数据库，key: {}", cacheKey);

// INFO：关键业务流程、状态变更
log.info("订单创建成功，订单号: {}, 用户ID: {}, 金额: {}", orderId, userId, amount);

// DEBUG：调试信息（生产环境关闭）
log.debug("查询参数: {}", params);
```

**关键信息包含**

业务日志必须包含：业务标识（订单号/用户ID）、操作主体（IP）、操作结果、核心参数。

**敏感信息脱敏**

```java
// ❌ 禁止直接打印
log.info("注册成功，手机: {}, 密码: {}", phone, password);

// ✅ 脱敏处理
log.info("注册成功，手机: {}", maskPhone(phone)); // 138****5678
```

必须脱敏：密码、手机号、身份证、银行卡、Token。

**日志打印位置**

✅ **必须打印**：方法入口/出口、关键业务节点、外部调用、异常捕获、定时任务开始/结束

❌ **禁止打印**：循环内 INFO 日志、工具方法、Getter/Setter

**异常日志规范**

```java
// ✅ 记录完整堆栈
log.error("支付失败，订单号: {}", orderId, e);

// ❌ 只记录 getMessage（丢失堆栈）
log.error("支付失败: {}", e.getMessage());

// ✅ 业务异常用 WARN，系统异常用 ERROR
catch (InsufficientBalanceException e) {
    log.warn("余额不足，用户ID: {}, 所需: {}", userId, amount);
}
```

避免重复记录异常，使用全局异常处理器统一记录。

**性能优化**

```java
// ❌ 字符串拼接（总会执行）
log.debug("用户: " + user.toString());

// ✅ 占位符（DEBUG关闭时不执行）
log.debug("用户: {}", user);

// ✅ 复杂计算前判断
if (log.isDebugEnabled()) {
    log.debug("详情: {}", buildDetail());
}

// ✅ 大集合只打印摘要
log.info("结果数: {}, 前3条: {}", list.size(), list.stream().limit(3).toList());
```

**审查检查清单**

```checklist
☐ 使用 @Slf4j 或 LoggerFactory，禁止 System.out/err
☐ 使用 {} 占位符，不用字符串拼接
☐ 敏感信息已脱敏（密码、手机号、身份证）
☐ 异常日志包含完整堆栈（log.error(msg, e)）
☐ 关键业务日志包含完整上下文（订单号、用户ID、结果）
☐ 不在循环内打印 INFO 日志
☐ 不在工具方法、Getter/Setter 中打印日志
☐ 大集合只打印数量和摘要
```

### Vue 体系

> 先根据 `package.json` 中的 `vue` 版本或脚手架特征（`vue-cli` vs `Vite`）确认版本，再选择对应 checklist。所有建议需兼顾 SSR/CSR、移动端兼容与构建产物大小。

#### Vue 2.x 审查要点

1. **Options API 规范**: `data` 返回函数、`props` 校验 `type/required/default` 完整，`methods/computed/watch` 分区清晰，禁止在 `created` 中执行 DOM 操作。
2. **响应式限制**: 关注 `Object.assign`、数组索引直接赋值是否触发响应式缺陷，必要时使用 `Vue.set`/`this.$set`；mixins 冲突需显式说明。
3. **生命周期与内存**: 核查 `beforeDestroy/destroyed` 中是否清理事件监听、定时器；`keep-alive` 组件是否正确监听 `activated/deactivated`。
4. **性能优化**: 大型表格/列表需结合 `virtual-scroller`，`v-for` 必须提供稳定 `key`，避免滥用 `this.$nextTick` 链。
5. **生态依赖**: 使用 Vue Router 3、Vuex 时，确认命名空间与模块拆分合理，SSR 项目避免在服务端访问 `window`。

#### Vue 3.x 审查要点

1. **Composition API 最佳实践**: `setup`/`<script setup>` 中解构 `reactive` 需配合 `toRefs`，业务逻辑抽离到 `composables/` 并附带副作用清理；`defineProps/defineEmits` 必须有类型声明。
2. **响应式系统升级**: 避免在模板外直接解构 `props` 引发丢失响应性，`watchEffect` 要求显式清理返回函数，`suspense/teleport` 使用需考虑 SEO/SSR。
3. **脚手架与构建**: 基于 Vite 的项目确认 `esbuild`/`rollup` 插件版本，检查 `tsconfig` 中的 `isolatedModules`、`strict` 选项与别名配置；确保 `env` 变量通过 `import.meta.env` 访问。
4. **类型与可维护性**: 强制 `defineExpose` 仅暴露必要接口，`emit` 事件需在 TS 中定义字面量联合类型，Pinia store 要求 `state/getters/actions` 类型齐备。
5. **性能与安全**: 大体积组件拆分 + `defineAsyncComponent` 懒加载，`v-memo/v-once` 合理使用；禁止在 `v-html` 中直接渲染后端字符串，统一调用 DOMPurify。

### 技术栈分层检查矩阵

#### Java 体系 - 按层级检查

> **重要**: 不同层级代码审查重点不同，需根据文件所属层级选择对应检查项

**Controller 层** (重点: 参数验证、权限、响应格式)

```checklist
职责检查:
☐ 仅负责参数接收、验证、调用 Service，不包含业务逻辑
☐ 未直接调用 Repository（应通过 Service）
☐ 未直接操作数据库

参数验证:
☐ 使用 @Valid 或 @Validated 验证请求参数
☐ 自定义参数校验器已实现（如业务规则验证）
☐ 参数类型明确（不使用 Map 作为参数）

权限控制:
☐ 敏感操作有 @PreAuthorize 权限检查
☐ 权限粒度合理（功能级或数据级）
☐ 权限验证不在业务代码中重复

响应格式:
☐ 返回统一的 ApiResponse 结构
☐ 响应包含适当的 HTTP 状态码（404/400/500）
☐ 敏感字段（密码等）不在响应中

异常处理:
☐ 不捕获异常（由全局异常处理器处理）
☐ 使用 throw new CustomException() 向外抛出
```

**Service 层** (重点: 业务逻辑、事务、异常处理)

```checklist
业务逻辑:
☐ 单一职责：每个方法只实现一个业务功能
☐ 逻辑清晰：方法长度 < 100 行，复杂度 < 10
☐ 无重复代码：相似逻辑已提取方法

事务控制:
☐ 使用 @Transactional 标注需要事务的方法
☐ 事务边界合理（不过大也不过小）
☐ 异常处理正确（RuntimeException 会导致回滚）
☐ 避免分布式事务（如无法避免，使用消息队列）

异常处理:
☐ 捕获 Repository 异常，转换为业务异常
☐ 自定义业务异常继承 RuntimeException
☐ 异常信息包含足够的上下文信息

关键操作日志:
☐ 登录、转账、删除等关键操作记录日志
☐ 日志包含用户标识、操作类型、时间戳

单元测试:
☐ 关键业务方法有单元测试
☐ 正常路径、异常路径都有测试用例
☐ 边界条件有测试（金额=0、列表=空等）
```

**Repository 层** (重点: SQL 安全、性能、数据一致性)

```checklist
SQL 安全:
☐ 使用参数化查询（MyBatis 的 #{} 或 JPA 的 ?）
☐ 禁止 SQL 字符串拼接（${}）
☐ 禁止直接执行动态 SQL（unless 必要且已验证）

查询优化:
☐ 明确指定需要的字段（不使用 SELECT *）
☐ WHERE/JOIN/ORDER BY 条件都有数据库索引
☐ 避免 N+1 查询（使用联表查询或 IN 子句）
☐ 分页查询提供 count 总数

批量操作:
☐ 使用 saveBatch() 或 updateBatch()（而非循环单条操作）
☐ 批量操作大小合理（通常 1000 条一批）

数据一致性:
☐ 使用乐观锁 @Version（处理并发修改）
☐ 逻辑删除使用 @TableLogic
☐ 自动填充字段使用 @TableField(fill=...)
☐ 主键生成策略明确指定

Entity 设计:
☐ 使用 Lombok @Data 简化代码
☐ 敏感字段使用 @JsonIgnore（防止序列化泄露）
☐ 日期字段统一使用 LocalDateTime
☐ 不在 Entity 中放置业务逻辑
```

---

#### Vue 体系 - 按层级检查

> **重要**: Vue 应用中不同层级代码有不同审查重点，需分类检查

**Page 组件** (重点: 路由参数、业务流程、数据管理)

```checklist
路由和参数:
☐ 从路由 query/params 中正确提取参数
☐ 参数验证和默认值处理
☐ 路由权限检查已实现

页面布局:
☐ 使用 <script setup> + Composition API
☐ 数据流向清晰（State → Computed → Template）
☐ 大型页面拆分为多个 Section 组件

Pinia Store 交互:
☐ 从 Store 获取必要的状态
☐ 页面改变的数据通过 Store Actions 提交
☐ Store 状态变化正确触发页面更新

生命周期:
☐ onMounted 中获取初始数据
☐ 路由参数变化时重新加载数据
☐ onBeforeUnmount 中清理事件/定时器

错误处理:
☐ 网络请求有错误处理（toast 提示）
☐ 关键操作有确认框
```

**通用组件** (重点: Props/Emits、响应式、复用性)

```checklist
Props 定义:
☐ 使用 defineProps 定义，有 TypeScript 类型
☐ 必要的 props 标记 required
☐ 提供合理的默认值
☐ Props 验证规则完整（type, validator 等）

Emits 定义:
☐ 使用 defineEmits 定义，有 TypeScript 类型
☐ Emit 的数据结构清晰
☐ Emit 事件名使用 kebab-case

响应式数据:
☐ 使用 ref 管理基础类型，reactive 管理对象
☐ 复杂对象使用 toRefs 解构（防止丢失响应性）
☐ computed 正确使用（只读或提供 setter）

V-for 和 Key:
☐ v-for 必须提供稳定的 key（通常是 id）
☐ 禁止用 index 作为 key
☐ 列表项不能有动态 class/style（影响性能）

组件大小:
☐ 组件代码 < 300 行
☐ 圈复杂度 < 10
☐ 复杂逻辑提取到 Composables

单元测试:
☐ 关键交互有单元测试
☐ Props/Emits 正确传递有测试
```

**Composable** (重点: 副作用清理、逻辑复用、类型安全)

```checklist
命名规范:
☐ 文件名以 use 开头（useXxx.ts）
☐ 返回对象的属性名清晰

副作用清理:
☐ watchEffect 提供 return cleanup 函数
☐ onMounted 中的事件监听在 onBeforeUnmount 中移除
☐ 定时器在组件销毁时 clearInterval
☐ 全局事件总线在卸载时取消订阅

依赖追踪:
☐ watch/watchEffect 的依赖项明确
☐ 避免无限监听循环（watchEffect 修改自身监听的值）

类型定义:
☐ 返回值有 TypeScript 类型声明
☐ 接收参数有类型标注

逻辑复用:
☐ 不依赖特定组件（可在多个组件复用）
☐ 异步操作有加载/错误状态
```

---

### 技术栈深度检查清单

#### Java 8 详细检查清单 (15 分钟)

```checklist
函数式编程:
☐ Lambda 表达式中没有未处理的受检异常
☐ Stream 终止操作正确（collect/forEach/reduce）
☐ Stream 避免嵌套过深（> 3 层）
☐ 避免在 Stream 中修改外部变量

Optional 使用:
☐ 禁止 return Optional.of(null)
☐ 链式调用有明确的终止操作（orElse/orElseThrow）
☐ 避免 Optional 作为参数传递
☐ isPresent() + get() 改为 ifPresentOrElse()

日期时间:
☐ 避免 java.util.Date（迁移到 java.time）
☐ SimpleDateFormat 使用 ThreadLocal（或改用 DateTimeFormatter）
☐ 避免在循环中创建 DateTimeFormatter
☐ 跨时区操作使用 ZonedDateTime

并发处理:
☐ CompletableFuture.join() 前有异常处理
☐ 异步操作提交到自定义线程池
☐ 线程池参数合理（coreSize/maxSize/queueSize）
```

#### Java 17 详细检查清单 (20 分钟)

```checklist
Record 使用:
☐ DTO/VO 类应用 record（替代 @Data）
☐ Record 未包含可变字段
☐ Record 序列化兼容性已验证（Jackson、Protobuf）
☐ Record 的 compact constructor 正确实现

文本块 (Text Block):
☐ 多行字符串使用 Text Block
☐ SQL/JSON 中特殊字符正确转义
☐ String.formatted() 用于参数替换
☐ 避免硬编码敏感信息

Pattern Matching:
☐ instanceof 使用 pattern binding（instanceof User u）
☐ switch 表达式使用 when 子句而非 if
☐ 避免过度使用 pattern（保持代码可读性）

密封类 (Sealed Class):
☐ 多态设计使用 sealed class 限制子类
☐ permits 子句明确列出所有实现

GC 和性能:
☐ 验证 Record/sealed 未增加 GC 压力
☐ 大堆场景检查是否适配 G1GC 默认配置
☐ 尚在使用旧版本依赖的需要升级评估
```

#### Vue 2.x 详细检查清单 (20 分钟)

```checklist
Options API 完整性:
☐ data() 返回函数，非对象
☐ props 有 type/required/default
☐ computed 提供 getter 和必要的 setter
☐ watch 的 immediate 和 deep 选项使用合理
☐ methods 不包含异步操作（改用 created/mounted）

响应式陷阱:
☐ 对象属性直接赋值使用 Vue.set()（或 this.$set）
☐ 数组元素修改使用 Vue.set()（禁止直接索引赋值）
☐ Object.assign() 修改对象使用 this.$set
☐ 避免修改 props（改为 data 副本）

生命周期管理:
☐ created 中不访问 DOM（应在 mounted）
☐ beforeDestroy 中清理事件监听 (off/unsubscribe)
☐ beforeDestroy 中清理定时器 (clearInterval/clearTimeout)
☐ keep-alive 组件监听 activated/deactivated

性能优化:
☐ 大列表 (> 100 项) 使用 virtual-scroller
☐ v-for 提供稳定 key（禁止 index）
☐ 避免 $nextTick 链式调用
☐ 计算属性代替模板中复杂表达式

Vuex / Vue Router:
☐ Store 模块使用 namespace
☐ Router 子路由组织清晰
☐ 避免在 store 中直接修改状态
```

#### Vue 3.x 详细检查清单 (25 分钟)

```checklist
Composition API 规范:
☐ setup() 或 <script setup> 中逻辑清晰
☐ defineProps/defineEmits 有完整类型声明
☐ reactive() 对象用 toRefs() 解构
☐ 避免在 setup 外直接解构 props（丢失响应性）

响应式系统:
☐ ref vs reactive 选择正确
☐ computed 用于派生状态（不修改原状态）
☐ watch 的依赖追踪正确
☐ watchEffect 提供 stop 函数（if needed）

副作用清理完整:
☐ watchEffect 包含 return cleanup 函数
☐ onMounted 的事件/定时器在 onBeforeUnmount 中清理
☐ Composable 中的 watch/watchEffect 自动清理
☐ 避免在 watch 中修改监听的数据（无限循环）

构建和配置:
☐ TypeScript strict: true
☐ isolatedModules: true（确保构建兼容性）
☐ vite.config.ts 的别名配置与 tsconfig.json 同步
☐ import.meta.env 获取环境变量（禁止 process.env）

组件分割和懒加载:
☐ 大组件拆分为多个小组件
☐ 路由使用 defineAsyncComponent() 懒加载
☐ 弹窗/抽屉等使用动态导入

性能优化:
☐ v-memo 优化静态内容列表
☐ v-once 用于不变内容
☐ 避免在模板中使用复杂计算
☐ Lighthouse 性能评分 > 90

Pinia Store 质量:
☐ state 返回对象（支持响应性）
☐ getters 有完整返回类型声明
☐ actions 标注异步（async/Promise）
☐ 避免在 action 中直接修改 state（改用 this.xxx = value）

安全检查:
☐ v-html 调用 DOMPurify 净化
☐ 禁止直接渲染用户输入的 HTML
☐ 表单输入有验证
☐ 敏感 API 调用有权限检查
```

#### Vue 2.x 快速检查清单 (10 分钟)

```checklist
响应式检查:
☐ data 中的属性是否都在声明时初始化？(避免后续直接赋值)
☐ 数组修改是否使用 Vue.set() 或 $set()？(避免直接索引赋值)
☐ Object.assign(this.obj, updates) 是否改用 this.$set？

性能检查:
☐ v-for 是否提供了稳定的 key？(禁止用 index)
☐ 大列表 (>100项) 是否使用了 virtual-scroller？
☐ 是否有多余的 $nextTick 链式调用？

生命周期检查:
☐ 事件监听 (addEventListener/subscribe) 是否在 beforeDestroy 中清理？
☐ keep-alive 组件是否监听了 activated/deactivated？
☐ 定时器是否在销毁时 clearInterval？

SSR 检查:
☐ 是否在 created 中访问了 window/document？(应在 mounted)
☐ 第三方库是否支持 SSR？
```

#### Vue 3.x 快速检查清单 (15 分钟)

```checklist
组合式 API 检查:
☐ reactive 对象是否用 toRefs 在模板中使用？(确保响应性)
☐ props 是否避免在组件外直接解构？(如在 setup 外赋值)
☐ defineProps/defineEmits 是否有完整类型？

副作用清理:
☐ watchEffect 是否包含 return cleanup 函数？(清理监听)
☐ onMounted 中的事件/定时器是否在 onBeforeUnmount 中清理？
☐ composable 中的 effect 是否自动清理？

构建配置检查:
☐ tsconfig.json 的 isolatedModules 是否为 true？
☐ env 变量是否通过 import.meta.env 访问？(禁止 process.env)
☐ 别名配置 (@/) 是否在 vite.config.ts 和 tsconfig.json 同步？

性能与安全:
☐ 大组件是否拆分并使用 defineAsyncComponent 懒加载？
☐ v-html 是否调用了 DOMPurify 净化？(禁止直接渲染用户输入)
☐ 动态组件列表是否添加了 v-memo？

Pinia store 检查:
☐ state 返回值是否是对象（支持响应性）？
☐ getters 是否有返回类型声明？
☐ actions 是否标注了异步性质（async/Promise）？
```

---

## 审查深度指南

### 何时需要业务上下文理解

> **重要**: 不是所有问题都能仅从代码看出，某些问题需要理解业务背景才能做出判断

#### 🟢 不需要业务理解（纯代码层面）

这些问题可以从代码结构、语法、规范直接识别：

- **编码规范**: 命名、格式、注释缺失
- **语言特性滥用**: Lambda 中未处理异常、Optional 用法错误
- **明显的性能问题**: N+1 查询、SELECT * 无索引的 WHERE
- **安全漏洞**: SQL 注入、XSS、硬编码密钥
- **复杂度问题**: 方法过长、嵌套过深、圈复杂度高
- **资源泄漏**: 文件未关闭、事件未清理、定时器未清除
- **类型安全**: 缺少类型声明、类型不匹配

**AI 审查建议**: 直接检查，无需业务背景，问题识别准确率 > 95%

---

#### 🟡 部分需要业务理解（混合判断）

这些问题需要结合代码实现与业务逻辑才能判断：

- **事务边界合理性**: 转账操作应该在一个事务内吗？还是分多步？
- **缓存策略**: 这个数据适合缓存吗？缓存时间应该多长？
- **数据一致性**: 并发修改这个字段会不会有业务问题？
- **异常处理**: 某个异常应该立即抛出还是可以忽略？
- **功能拆分**: 这个 Service 方法职责是否单一？还是需要进一步拆分？
- **流程设计**: 这个审批流程设计是否合理？缺少哪些检查点？

**AI 审查建议**: 
- 可以识别"代码结构不合理"，但无法判断"业务逻辑是否正确"
- 建议给出多种可能的问题，标记为"需要业务确认"
- 例如: "⚠️ 需确认: 这个查询跨 3 个表联接，是否每次都需要全部字段？可考虑缓存或异步加载"

---

#### 🔴 必须需要业务理解（业务风险）

这些问题涉及核心业务逻辑，代码审查无法替代业务理解：

- **业务规则检查**: 订单金额是否有最大/最小限制？折扣规则是否符合成本控制要求？
- **数据正确性验证**: 这个计算是否会导致资金错账？权益是否可能重复发放？
- **流程合规性**: 关键操作是否记录审计日志？是否满足法规要求？
- **并发竞态**: 多用户同时操作会不会有数据冲突？库存超卖风险？
- **边界条件**: 金额为 0、负数、极大值时系统如何处理？是否符合业务预期？
- **功能完整性**: 是否遗漏了某些业务规则？例如 VIP 用户的特殊处理

**AI 审查建议**: 
- 标记"需要业务评审"，不给出最终判断
- 例如: "🔴 需业务评审: 当库存为 0 时，系统是否应该接受订单？建议与产品确认处理策略"
- 重点关注代码是否有"防御性编程"，即使不理解业务也能发现缺陷

---

### 不同审查等级的上下文需求

#### 基础审查 (15-30min)

| 检查项 | 需要业务理解 | 说明 |
|--------|-------------|------|
| 编码规范 | ❌ 否 | 纯语法和格式检查 |
| 类型安全 | ❌ 否 | TypeScript/Java 类型系统 |
| 明显的 Bug | ⚠️ 部分 | 空指针、数组越界、资源泄漏不需要；业务逻辑错误需要 |
| 安全漏洞 | ❌ 否 | SQL 注入、XSS 无需理解业务 |

**AI 适配**: 完全可以独立完成，准确率 90%+

---

#### 标准审查 (45-60min)

| 检查项 | 需要业务理解 | 说明 |
|--------|-------------|------|
| 架构设计 | ⚠️ 部分 | 服务拆分的合理性取决于业务模型 |
| 性能优化 | ⚠️ 部分 | 缓存策略、查询优化通常涉及业务特性 |
| 事务控制 | ⚠️ 部分 | 事务边界涉及一致性要求 |
| 流程正确性 | 🔴 是 | 审批流程、支付流程需要业务确认 |

**AI 适配**: 可以识别结构问题，但最终判断需要业务确认

**建议做法**:
```
AI 审查输出：
- ✅ 代码结构问题：[具体列出]
- ⚠️ 可能的性能风险：[列出并说明影响]
- 🔴 需业务确认：[标记需要业务方确认的决策点]
```

---

#### 专业审查 (2-3h)

| 检查项 | 需要业务理解 | 说明 |
|--------|-------------|------|
| 系统架构评估 | 🔴 是 | 需要理解业务增长计划 |
| 容量规划 | 🔴 是 | 并发数、数据量预期 |
| 关键业务逻辑 | 🔴 是 | 支付、转账、库存等核心流程 |
| 扩展性设计 | ⚠️ 部分 | 代码层面可评估，业务需求确认需要业务方 |
| 灾难恢复 | 🔴 是 | RPO/RTO 由业务方定义 |

**AI 适配**: 主要做代码检查，业务决策由人工评审

---

### AI 代码审查的准确率参考

| 审查维度 | 准确率 | 限制 | 建议 |
|---------|--------|------|------|
| 编码规范 | 95%+ | 风格问题较少有误判 | 可直接执行 |
| 编程错误 | 90%+ | 可能漏掉隐蔽的逻辑错误 | 与人工评审结合 |
| 安全漏洞 | 85%+ | 新型攻击可能无法识别 | 配合安全扫描工具 |
| 性能问题 | 75%+ | 基准不清楚，难判断"是否达标" | 需性能基准表 |
| 架构设计 | 60%+ | 业务背景不足，可能误判设计 | 需业务确认 |
| 业务正确性 | 30%+ | 不理解业务规则，很难识别逻辑错误 | 必须人工评审 |

---

### AI 审查的最佳实践

#### ✅ 做这些（高准确率）

1. **使用检查清单**: 依赖具体的检查项，避免模糊判断
2. **基于代码规范**: 优先检查"是否违反规范"而非"是否最优"
3. **标记不确定项**: 明确指出"需要业务确认"的决策
4. **提供多种方案**: 当有多种实现方式时，列出优缺点
5. **引入自动化工具**: 结合 SonarQube、ESLint 消除争议

#### ❌ 不要做这些（低准确率）

1. **纯主观判断**: "这个设计不好" 无法量化
2. **忽视业务背景**: 未理解业务就判断"不必要的代码"
3. **过度优化建议**: 建议过多导致"完美主义"陷阱
4. **混淆代码问题和设计问题**: 有些是架构层面，不是代码层面
5. **一刀切的标准**: 同样的代码在不同场景可能是"良好"或"过度工程"

---

## 问题分类与优先级

### 问题优先级

```
🔴 P0 - 关键问题 (立即修复)
   ├─ 安全漏洞 (SQL 注入、XSS、权限绕过)
   ├─ 数据正确性 (逻辑错误、数据丢失)
   ├─ 系统崩溃 (NPE、无限循环、内存溢出)
   └─ 规范违反 (违反基本编码规范)

⚠️ P1 - 重要问题 (本周内修复)
   ├─ 性能问题 (N+1查询、内存泄漏)
   ├─ 可维护性 (方法过长、复杂度高)
   ├─ 不完整异常处理
   └─ 缺少关键日志

🟢 P2 - 优化建议 (下个迭代)
   ├─ 代码风格改进
   ├─ 补充注释和文档
   ├─ 单元测试补充
   └─ 性能微调
```

### 问题示例

| 问题 | 严重级别 | 示例 | 修复时间 |
|------|---------|------|---------|
| SQL 注入 | 🔴 P0 | 字符串拼接SQL | 立即 |
| N+1查询 | ⚠️ P1 | 循环内查询 | 本周 |
| 缺少缓存 | 🟢 P2 | 热点查询重复 | 迭代 |
| 缺少注释 | 🟢 P2 | 公开方法无文档 | 迭代 |

---

## 审查报告模板

### 报告结构

```markdown
# 代码审查报告

**项目**: [项目名] | **模块**: [模块] | **时间**: [YYYY-MM-DD]
**审查人**: [审查者] | **综合得分**: **XX/100** (A/B/C/D级)

## 📊 质量评估

| 维度 | 得分 | 权重 | 加权分 | 状态 | 主要问题 |
|------|------|------|--------|------|---------|
| 编码规范 | 75/100 | 30% | 22.5 | ⚠️ | 缺少注释、魔法值 |
| 架构设计 | 80/100 | 20% | 16 | ✅ | 职责清晰 |
| 安全防护 | 70/100 | 20% | 14 | ⚠️ | 输入验证不完整 |
| 性能优化 | 75/100 | 15% | 11.25 | ⚠️ | 缺少缓存 |
| 可维护性 | 80/100 | 15% | 12 | ✅ | 测试覆盖率70% |
| **综合得分** | | | **75.75** | **B级** | |

## 🔴 关键问题 (P0 - 立即修复)

1. **SQL 注入风险** - `UserMapper.java:45`
   - 问题: 使用 `${}` 拼接用户输入
   - 影响: 数据泄露、数据库被破坏
   - 修复: 改用 `#{}` 参数化查询

2. **敏感数据泄露** - `UserResponse.java:20`
   - 问题: 响应返回用户密码字段
   - 影响: 密码泄露风险
   - 修复: 移除 password 字段

## ⚠️ 重要问题 (P1 - 本周内修复)

1. **N+1 查询问题** - `OrderService.java:56`
   - 当前: 循环内执行 SQL 查询 (可能执行 1001 次查询)
   - 改进: 使用 IN 子句或批量查询 (只需 2 次查询)
   - 预期收益: 性能提升 50%

2. **缺少事务控制** - `UserService.java:78`
   - 当前: 转账操作未使用 @Transactional
   - 改进: 添加事务注解，确保原子性
   - 预期收益: 防止数据不一致

## 🟢 优化建议 (P2 - 下个迭代)

1. **补充文档注释** - `UserController.java`
   - 当前: 公开方法无 JavaDoc
   - 建议: 添加类和方法注释

2. **增加单元测试** - 整体
   - 当前: 测试覆盖率 60%
   - 建议: 提升至 80%

## 📋 改进行动计划

| 问题 | 优先级 | 指派人 | 完成期限 | 状态 |
|------|--------|--------|---------|------|
| SQL 注入修复 | P0 | @dev1 | 2024-01-15 | ⏳ |
| N+1 优化 | P1 | @dev2 | 2024-01-20 | ⏳ |
| 文档补充 | P2 | @dev3 | 2024-02-01 | ⏳ |

## ✅ 建议事项

- 引入 SonarQube 自动检查，捕获常见问题
- 团队定期培训，分享最佳实践
- 建立代码审查反馈机制，持续改进
```

---

## 实施建议

### 审查工具链

**静态分析工具**:
- Java: SonarQube、Checkstyle、SpotBugs
- Vue/JavaScript: ESLint、Prettier、SonarJS
- 通用: Git Hook (pre-commit)

**审查流程**:
1. 自动检查 (静态分析工具)
2. 人工审查 (架构、设计、性能)
3. 沟通反馈 (明确问题、讨论方案)
4. 验收检查 (确认修复)

### 团队协作

**统一标准**:
- 制定项目编码规范文档
- 建立审查检查清单
- 定期更新最佳实践

**持续反馈**:
- 定期分享审查经验
- 总结常见问题模式
- 优化审查流程

### 质量指标

| 指标 | 目标 | 说明 |
|------|------|------|
| 代码审查通过率 | ≥95% | P0 问题 100% 修复 |
| 平均审查时间 | 1h/300行 | 基准:50行/15min |
| 测试覆盖率 | ≥75% | 确保功能正确性 |
| 缺陷逃逸率 | <1% | 审查后发现的缺陷 |

---

## 常见误区

### ❌ 不要做

1. **形式化审查**: 只看格式，不看逻辑
2. **完美主义**: 过度追求代码风格一致
3. **知识垄断**: 审查人是瓶颈，知识无法传递
4. **人身攻击**: 批评代码，不批评写代码的人
5. **过度优化**: 追求极端性能，牺牲可读性

### ✅ 应该做

1. **聚焦关键**: 优先关注安全、性能、架构
2. **要求合理**: 制定符合项目阶段的标准
3. **知识分享**: 审查是教学过程，传递最佳实践
4. **建设性反馈**: 提出问题，提供解决方案
5. **平衡取舍**: 根据项目目标权衡各维度

---

## 总结

有效的代码审查需要：

1. **清晰的标准** - 五维度框架，权重化评分
2. **系统的流程** - 三级审查体系，分步执行
3. **可执行的建议** - 每个问题都有改进方案
4. **持续的改进** - 反馈机制，优化流程

代码审查的最终目标不是**指责缺陷**，而是**提升品质**，通过知识分享促进团队整体进步。

---

## 📚 相关文档

本文档作为代码审查最佳实践的核心指南，建议与配合以下技能使用：

**技能相关**：
- `cr-java-code` - Java 代码审查技能
- `cr-vue-code` - Vue 代码审查技能

---

## 📝 维护记录

| 时间 | 维护人 | 维护内容 | 版本 |
|------|--------|----------|------|
| 2025-11-12 | johnsonyang | 新增 Java 日志打印规范章节：日志框架、级别、内容、时机、异常处理、性能优化等 9 个方面 | v2.1 |
| 2025-11-26 | johnsonyang | 增补 P0 缺陷改进：分层检查矩阵、深度检查清单、审查深度指南、判分示例扩展 | v2.0 |
| 2025-11-26 | johnsonyang | 补充单维度量化标准、4 个真实判分示例、技术栈快速清单、深度检查清单 | v1.5 |
| 2025-11-26 | johnsonyang | 初始创建：五维度框架、三级审查体系、基础检查清单、问题分类优先级 | v1.0 |

---

**文档结束** | 代码审查通用最佳实践 | 适用于多技术栈团队的代码质量管理体系

---
