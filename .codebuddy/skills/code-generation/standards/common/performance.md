# 通用性能规范

适用于所有语言的性能优化最佳实践。

---

## 性能优化原则

| 原则 | 说明 |
|------|------|
| 先测量后优化 | 基于数据而非猜测 |
| 优化热点 | 关注 20% 的热点代码 |
| 权衡取舍 | 性能 vs 可读性/可维护性 |
| 避免过早优化 | 先正确，再快速 |

---

## 数据库性能

### 查询优化

```yaml
必须:
  - ✅ 使用索引（高频查询字段）
  - ✅ 避免 SELECT *
  - ✅ 使用分页查询
  - ✅ 避免 N+1 查询

建议:
  - 使用 EXPLAIN 分析查询计划
  - 大表查询使用覆盖索引
  - 避免在索引列上使用函数
```

### 索引规范

```yaml
创建索引:
  - 主键（自动）
  - 外键
  - WHERE 条件字段
  - ORDER BY 字段
  - JOIN 字段

避免:
  - 过多索引（影响写入）
  - 低选择性字段索引
  - 频繁更新的字段索引
```

### 分页查询

```yaml
推荐方式:
  - 游标分页（大数据量）
  - 偏移分页（小数据量）

限制:
  - 单页最大 100 条
  - 深度分页使用游标
```

---

## 缓存策略

### 缓存层级

```yaml
L1 - 本地缓存:
  - 适用: 热点数据、配置信息
  - 工具: Caffeine, Guava Cache
  - 特点: 速度快，容量小

L2 - 分布式缓存:
  - 适用: 共享数据、会话信息
  - 工具: Redis, Memcached
  - 特点: 容量大，网络开销

L3 - CDN 缓存:
  - 适用: 静态资源、公共数据
  - 特点: 边缘节点，就近访问
```

### 缓存策略

```yaml
读取策略:
  Cache-Aside: 应用管理缓存
  Read-Through: 缓存管理数据源
  
写入策略:
  Write-Through: 同步写入缓存和数据源
  Write-Behind: 异步写入数据源
  
失效策略:
  TTL: 固定过期时间
  LRU: 最近最少使用
  LFU: 最不经常使用
```

### 缓存问题防护

```yaml
缓存穿透:
  - 问题: 查询不存在的数据
  - 方案: 布隆过滤器、缓存空值

缓存击穿:
  - 问题: 热点 key 过期
  - 方案: 互斥锁、永不过期

缓存雪崩:
  - 问题: 大量 key 同时过期
  - 方案: 随机过期时间、多级缓存
```

---

## 异步处理

### 适用场景

```yaml
适合异步:
  - 发送邮件/短信
  - 日志记录
  - 数据同步
  - 文件处理
  - 第三方 API 调用

不适合异步:
  - 需要立即返回结果
  - 事务性操作
  - 简单快速的操作
```

### 异步模式

```yaml
消息队列:
  - 适用: 解耦、削峰、异步
  - 工具: Kafka, RabbitMQ, RocketMQ

线程池:
  - 适用: 并行处理
  - 注意: 线程数配置、拒绝策略

事件驱动:
  - 适用: 响应式处理
  - 工具: Spring Events, Node.js EventEmitter
```

---

## 资源管理

### 连接池

```yaml
数据库连接池:
  - 最小连接数: 5-10
  - 最大连接数: 20-50
  - 超时时间: 30s
  - 空闲检测: 60s

HTTP 连接池:
  - 最大连接数: 100-200
  - 每个路由最大连接: 20-50
  - 超时时间: 10s
```

### 资源释放

```yaml
必须释放:
  - 数据库连接
  - 文件句柄
  - 网络连接
  - 线程资源

释放方式:
  - try-with-resources (Java)
  - defer (Go)
  - with 语句 (Python)
  - finally 块
```

---

## 算法优化

### 时间复杂度

```yaml
优先选择:
  O(1) > O(log n) > O(n) > O(n log n) > O(n²)

常见操作:
  - HashMap 查找: O(1)
  - 二分查找: O(log n)
  - 数组遍历: O(n)
  - 排序: O(n log n)
  - 嵌套循环: O(n²)
```

### 空间优化

```yaml
减少内存:
  - 使用基本类型而非包装类型
  - 使用 StringBuilder 拼接字符串
  - 预分配集合大小
  - 及时释放不用的对象

流式处理:
  - 大文件分块读取
  - 数据库游标查询
  - 响应式流处理
```

---

## 性能指标

### 响应时间

```yaml
Web API:
  - P50 < 100ms
  - P95 < 200ms
  - P99 < 500ms

数据库查询:
  - 简单查询 < 10ms
  - 复杂查询 < 100ms
  - 报表查询 < 1s
```

### 吞吐量

```yaml
评估指标:
  - QPS (Queries Per Second)
  - TPS (Transactions Per Second)
  - 并发用户数

基准:
  - 单机 API: 1000-5000 QPS
  - 数据库: 5000-20000 QPS
```

---

## 性能测试

### 测试类型

```yaml
基准测试:
  - 单一功能性能
  - 工具: JMH, BenchmarkDotNet

负载测试:
  - 正常负载下的性能
  - 工具: JMeter, Gatling

压力测试:
  - 极限负载下的表现
  - 找出系统瓶颈

容量测试:
  - 确定系统容量上限
  - 规划扩容策略
```

### 性能分析工具

```yaml
Java:
  - JProfiler, VisualVM, Arthas
  
Go:
  - pprof, trace
  
Node.js:
  - clinic, 0x
  
通用:
  - Prometheus + Grafana（监控）
  - Jaeger, Zipkin（链路追踪）
```

---

## 检查清单

- [ ] 数据库查询有索引
- [ ] 避免 N+1 查询
- [ ] 使用分页查询
- [ ] 热点数据有缓存
- [ ] 耗时操作异步处理
- [ ] 资源正确释放
- [ ] 有性能基准测试
- [ ] 监控关键性能指标
