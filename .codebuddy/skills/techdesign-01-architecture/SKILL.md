---
name: techdesign-01-architecture
description: 从系统层面设计整体架构 - 架构风格选择、技术选型、模块划分、非功能需求实现、部署架构设计
category: techdesign
keywords: [架构设计, 系统设计, 微服务, 分层架构, 高可用]
---

## 工作流位置

```
techdesign-01 架构设计 ← 当前技能
    ↓ 输出：架构方案、技术选型、模块划分
techdesign-02 流程设计（可选，复杂业务流程时使用）
    ↓ 输出：流程图、状态机
techdesign-03 功能设计
    ↓ 输出：功能规格、用例设计
techdesign-04 实体设计
    ↓ 输出：实体模型、领域模型
techdesign-05 数据库设计 ─┬─ 可并行
techdesign-06 API设计    ─┘
    ↓ 输出：DDL、API文档
techdesign-07 交付规划（可选，需要项目管理时使用）
```

**上游输入**: 需求文档、业务分析输出
**下游使用**: 02-process、03-feature、04-entity 将使用本技能输出的架构方案

## 路径选择指南

根据不同场景选择合适的技术设计路径：

### 场景路径速查表

| 场景 | 推荐路径 | 说明 |
|------|---------|------|
| 🆕 **新系统开发** | 01→02→03→04→05+06→07 | 完整路径，从架构到交付 |
| ➕ **新功能开发** | 03→04→05+06 | 跳过架构，聚焦功能实现 |
| 🔌 **API 优先** | 01→03→06→04→05 | 先定义接口契约，再建模 |
| 📊 **数据驱动** | 01→04→05→03→06 | 先建模，再定义功能和接口 |
| ⚡ **快速原型** | 03→06 | 最小路径，快速验证想法 |
| 🔧 **遗留系统改造** | 01→02→03 | 聚焦架构和流程重构 |

### 路径决策树

```
开始
 │
 ├─ 是新系统吗？
 │   ├─ 是 → 完整路径: 01→02(可选)→03→04→05+06→07(可选)
 │   └─ 否 → 继续判断
 │
 ├─ 需要重构架构吗？
 │   ├─ 是 → 从 01 开始
 │   └─ 否 → 跳过 01
 │
 ├─ 有复杂业务流程吗？（多状态、审批流、多角色）
 │   ├─ 是 → 包含 02
 │   └─ 否 → 跳过 02
 │
 ├─ 前后端分离/对外接口？
 │   ├─ 是 → API 优先: 先 06 再 05
 │   └─ 否 → 数据优先: 先 05 再 06
 │
 └─ 需要项目管理？
     ├─ 是 → 包含 07
     └─ 否 → 跳过 07
```

### 各路径详细说明

#### 🆕 新系统开发（完整路径）
```
01-architecture → 02-process(可选) → 03-feature → 04-entity → 05-database + 06-api → 07-delivery-planning(可选)
```
- **适用**: 从零开始的新项目
- **特点**: 系统性、完整性、可追溯

#### ➕ 新功能开发
```
03-feature → 04-entity → 05-database + 06-api
```
- **适用**: 在现有系统上添加新功能
- **特点**: 复用现有架构，聚焦功能实现

#### 🔌 API 优先
```
01-architecture → 03-feature → 06-api → 04-entity → 05-database
```
- **适用**: 前后端分离、对外开放 API、契约优先开发
- **特点**: 先定义接口契约，团队可并行开发

#### 📊 数据驱动
```
01-architecture → 04-entity → 05-database → 03-feature → 06-api
```
- **适用**: 数据密集型应用、报表系统、数据仓库
- **特点**: 数据模型稳定后再定义功能

#### ⚡ 快速原型
```
03-feature → 06-api
```
- **适用**: MVP 验证、概念验证、Demo 开发
- **特点**: 最小路径，快速交付

#### 🔧 遗留系统改造
```
01-architecture → 02-process → 03-feature
```
- **适用**: 技术债务清理、架构升级、流程优化
- **特点**: 聚焦重构，保留现有数据层

> ⚠️ **必读**: [通用规范](mdc:.codebuddy/spec/global/standards/common/index.md) - 项目记忆引用和所有规范要求

# 系统架构设计

## 核心原则(15秒速查)

1. **团队熟悉度 > 技术先进性** - 选择团队会用的技术
2. **架构匹配规模** - 小项目单体，大项目微服务
3. **非功能需求量化** - 具体数字，不用"高性能"等模糊词
4. **模块单向依赖** - 避免循环依赖
5. **优先简单方案** - 满足需求即可，避免过度设计
6. **决策可追溯** - 重要决策记录 ADR（架构决策记录）

## 技能信息

### 文档输出
- 遵循 [文档生成原则](mdc:.codebuddy/spec/global/standards/common/document-generation-rules.md)
- 输出路径: `workspace/{变更ID}/design/architecture.md`
- 只在用户明确要求时生成文档

### 职责边界
专注系统架构设计:
- 架构风格选择(单体/微服务/Serverless)
- 技术栈选型和版本确定
- 模块划分和边界定义
- 非功能需求实现方案
- 部署架构和运维方案

不涉及:
- ❌ API 接口设计 → 使用 `techdesign-06-api`
- ❌ 数据库表设计 → 使用 `techdesign-05-database`
- ❌ 业务流程设计 → 使用 `techdesign-02-process`

---

## 使用场景

### 何时使用
- 新项目启动，需要选择技术栈和架构风格
- 需要设计系统的整体架构
- 需要量化非功能需求(性能、可用性、安全性)
- 需要规划部署和监控方案

### 何时不用
- 简单功能迭代，不涉及架构调整 → 直接设计功能
- 架构已确定，只做局部优化 → 不需要完整架构设计

### 前置条件
- 需求文档存在: `workspace/{变更ID}/requirements/requirements.md`
- 功能需求明确、非功能需求量化、技术约束清晰

---

## 设计流程

### 1. 选择架构风格

基于以下维度选择:

| 维度 | 单体架构 | 微服务架构 | Serverless |
|------|---------|-----------|-----------|
| 系统规模 | < 10 模块 | > 20 模块 | 事件驱动 |
| 团队规模 | < 10 人 | > 30 人 | 不限 |
| 开发周期 | 快速迭代 | 长期演进 | 快速原型 |
| 运维成本 | 低 | 高 | 极低 |
| 扩展性 | 差 | 优秀 | 优秀 |

**决策模板**:
```markdown
## 架构风格决策

**选择**: [单体/微服务/Serverless]

**理由**:
- 系统规模: [X 个核心模块]
- 团队规模: [X 人]
- 性能要求: [QPS、响应时间]
- 扩展性要求: [是否需要横向扩展]

**权衡**:
优点: [...]
缺点: [...] 
应对措施: [...]
```

---

### 2. 技术选型

**选型原则**:
```
1. 团队熟悉度 > 技术先进性
2. 生态成熟度 > 功能完整性
3. 性能满足 > 性能极致
4. 长期维护 > 短期便利
```

**参考技术栈**(参考 [技术栈索引](mdc:.codebuddy/spec/global/knowledge/stack/index.md)):

后端框架:
- Spring Boot 3.2+(推荐)
- Quarkus(云原生场景)

ORM:
- MyBatis-Plus 3.5+(推荐 - 灵活、高性能)
- JPA/Hibernate(标准化需求)

数据库:
- MySQL 8.0+(通用场景，推荐)
- PostgreSQL 14+(复杂查询)

缓存:
- Redis 7.x(推荐)

消息队列:
- Kafka(大数据、高吞吐)
- RabbitMQ(复杂路由)

前端框架:
- Vue 3(中小型项目)

**决策模板**:
```markdown
## 技术选型决策

### 后端技术栈
- 编程语言: Java 17
- 后端框架: Spring Boot 3.2
- ORM: MyBatis-Plus 3.5
- 数据库: MySQL 8.0
- 缓存: Redis 7.x

### 前端技术栈
- 前端框架: Vue 3
- UI 组件库: TDesign
- 构建工具: Vite

### 每个技术选择理由(团队、性能、生态等)
```

---

### 3. 模块划分

**原则**:
- 按业务领域划分，不按技术层划分
- 单一职责，避免循环依赖
- 模块职责清晰，边界明确

**单体架构模块结构**:
```
src/main/java/com/example/project/
├── user/           # 用户模块
│   ├── controller/
│   ├── service/
│   ├── mapper/
│   └── entity/
├── product/        # 商品模块
├── order/          # 订单模块
├── payment/        # 支付模块
└── common/         # 通用模块
```

**微服务架构服务划分**:
```
├─ 用户服务 (User Service)
│  ├─ 职责: 用户注册、登录、信息管理
│  ├─ 数据存储: user_db
│  └─ 依赖: 无
├─ 订单服务 (Order Service)
│  ├─ 职责: 订单创建、查询、状态管理
│  ├─ 数据存储: order_db
│  └─ 依赖: 用户服务、商品服务、支付服务
```

**模块职责定义模板**:
```markdown
### 用户模块

**职责**:
- 用户注册、登录(OAuth、JWT)
- 用户信息管理(CRUD)
- 用户认证和授权(RBAC)

**对外接口**:
- POST /api/users/register - 用户注册
- POST /api/users/login - 用户登录
- GET /api/users/{id} - 获取用户信息

**依赖**: 无(基础模块)
**被依赖**: 订单模块、支付模块
```

**避免循环依赖**:
- ✅ 用户模块 ← 订单模块(单向)
- ❌ 用户模块 ↔ 订单模块(双向)

---

### 4. 非功能需求实现

**必须量化所有指标**，避免"高性能"等模糊词。

#### 性能优化

**多级缓存**:
```
L1 缓存: 本地缓存(Caffeine) - 热点数据、容量10000条、过期5分钟
L2 缓存: Redis - 用户会话、商品信息、过期30分钟-24小时
L3 存储: MySQL - 持久化存储
```

**数据库优化**:
```
索引设计:
- 主键索引: 所有表
- 唯一索引: 业务唯一字段(用户名、手机号)
- 普通索引: 高频查询字段(状态、创建时间)

读写分离:
- 主库: 写操作
- 从库: 读操作

分库分表: 单表数据量 > 1000万行时触发
```

**负载均衡**:
```
Nginx / HAProxy
- 算法: 轮询、最少连接、IP Hash
- 健康检查: 每10秒检测，3次失败剔除
```

#### 高可用方案

**应用层**:
```
多实例部署: 最少2个(故障转移)，推荐3-5个(滚动发布)
自动扩缩容: CPU使用率 > 70%扩容
Kubernetes: 自动重启故障容器
```

**数据层**:
```
MySQL主从: 1主2从
同步模式: 半同步复制
故障转移: < 30秒
数据备份: 全量备份每天凌晨，增量备份每小时，保留30天
```

**监控告警**:
```
系统监控: Prometheus + Grafana
- CPU > 80%、内存 > 90%、磁盘 > 85%告警

应用监控:
- 错误率 > 1%、响应时间P95 > 500ms告警

业务监控:
- 订单量异常下降、支付成功率 < 95%告警
```

#### 安全防护

**认证授权**:
```
JWT Token: 访问令牌2小时，刷新令牌7天
RBAC: 基于角色的权限控制
```

**数据安全**:
```
传输加密: HTTPS(TLS 1.2+)
存储加密: 密码BCrypt，敏感字段AES-256
数据脱敏: 日志、显示、导出时自动脱敏
```

**攻击防护**:
```
SQL注入: 参数化查询，使用MyBatis #{}而非${}
XSS: HTML转义，CSP策略
CSRF: CSRF Token，SameSite Cookie
DDoS: CDN，单IP限制100 QPS，WAF
暴力破解: 5次失败锁定15分钟
```

#### 扩展性方案

**横向扩展**:
```
无状态设计: 会话存储在Redis
容器化部署: Docker + Kubernetes
自动扩缩容: HPA(Horizontal Pod Autoscaler)
```

---

### 5. 部署架构

**环境划分**:
```
开发环境(Dev): 本地开发、Docker Compose
测试环境(Test): 集成测试、Kubernetes/云服务器
预发环境(Staging): 生产镜像、灰度验证
生产环境(Prod): 正式环境、高可用、多机房
```

**CI/CD流程**:
```
持续集成(CI):
1. 代码提交 → 自动构建
2. 编译打包(Maven/Gradle/npm)
3. 自动测试(单元测试、集成测试)
4. 质量检查(SonarQube、ESLint)
5. 推送镜像到镜像仓库

持续部署(CD):
1. 测试环境自动部署
2. 生产环境灰度发布(10% → 50% → 100%)
3. 异常自动回滚(错误率 > 1%)
```

**工具链**:
```
代码托管 + CI/CD: GitLab CI / GitHub Actions
Kubernetes部署: ArgoCD、Helm
镜像仓库: Harbor / Docker Hub
```

**日志和监控**:
```
日志: Fluentd/Filebeat → Elasticsearch → Kibana
监控: Prometheus → Grafana
链路追踪: SkyWalking / Zipkin
```

**灾备方案**:
```
备份策略:
- 全量备份: 每天凌晨2点
- 增量备份: 每小时
- Binlog备份: 实时

保留策略:
- 每日备份: 保留7天
- 每周备份: 保留4周
- 每月备份: 保留12个月

RTO: 30分钟内恢复服务
RPO: 数据损失 < 5分钟
```

---

### 6. 输出架构文档

**输出路径**: `workspace/{变更ID}/design/architecture.md`

**文档结构**:
```markdown
# 系统架构设计文档

## 1. 架构概述
[架构风格、架构图、关键设计决策]

## 2. 技术选型
[技术栈清单、版本要求、选型理由]

## 3. 模块/服务划分
[模块清单、职责定义、依赖关系]

## 4. 非功能需求实现
[性能、可用性、安全性、扩展性方案]

## 5. 部署架构
[部署方式、CI/CD、监控日志、灾备方案]

## 6. 架构演进计划
[当前局限、演进方向、具体计划]
```

---

## 架构决策记录 (ADR)

重要架构决策必须记录，便于追溯和评审。

**ADR 模板**:
```markdown
## ADR-{序号}: {决策标题}

**状态**: 提议 | 已接受 | 已废弃 | 已取代
**日期**: YYYY-MM-DD
**决策者**: {团队/人员}

### 背景
{描述问题背景和约束条件}

### 决策
{描述做出的决策}

### 理由
{解释为什么做出这个决策}
- 考虑因素1: ...
- 考虑因素2: ...

### 后果
**优点**:
- ...

**缺点**:
- ...

**风险**:
- ...

### 替代方案
| 方案 | 优点 | 缺点 | 否决原因 |
|------|------|------|---------|
| 方案A | ... | ... | ... |
| 方案B | ... | ... | ... |
```

**ADR 示例**:
```markdown
## ADR-001: 选择微服务架构

**状态**: 已接受
**日期**: 2025-01-15
**决策者**: 架构组

### 背景
系统预计支持 50+ 模块，团队 30+ 人，需要独立部署和扩展能力。

### 决策
采用微服务架构，按业务领域拆分服务。

### 理由
- 团队规模大，需要独立开发和部署
- 业务模块间耦合度低，适合拆分
- 需要针对性扩展高流量服务

### 后果
**优点**: 独立部署、技术异构、团队自治
**缺点**: 运维复杂度增加、分布式事务挑战
**风险**: 服务间通信延迟、数据一致性

### 替代方案
| 方案 | 优点 | 缺点 | 否决原因 |
|------|------|------|---------|
| 模块化单体 | 简单、事务容易 | 扩展性受限 | 无法满足团队规模 |
| Serverless | 极低运维 | 冷启动、厂商锁定 | 不适合复杂业务 |
```

---

## 架构评估方法 (ATAM)

对于重要架构决策，使用 ATAM（架构权衡分析法）进行评估。

**评估步骤**:
1. **识别质量属性场景**: 性能、可用性、安全性、可维护性
2. **分析架构方法**: 识别架构如何满足质量属性
3. **识别敏感点**: 影响多个质量属性的架构决策
4. **识别权衡点**: 质量属性之间的冲突
5. **风险评估**: 识别潜在风险

**质量属性场景模板**:
```markdown
| 属性 | 场景 | 刺激 | 响应 | 度量 |
|------|------|------|------|------|
| 性能 | 高并发查询 | 1000 QPS | 返回结果 | P95 < 200ms |
| 可用性 | 服务故障 | 单节点宕机 | 自动切换 | 恢复 < 30s |
| 安全性 | 恶意攻击 | SQL注入 | 拦截请求 | 100%拦截 |
| 可维护性 | 功能变更 | 新增模块 | 独立部署 | < 1天 |
```

**权衡分析示例**:
```markdown
### 权衡点: 性能 vs 一致性

**场景**: 订单状态查询
**方案A**: 强一致性（同步读主库）
- 性能: P95 = 150ms
- 一致性: 100%

**方案B**: 最终一致性（读从库 + 缓存）
- 性能: P95 = 30ms
- 一致性: 99.9%（延迟 < 1s）

**决策**: 选择方案B，业务可接受短暂延迟
```

---

## 质量检查

### 架构设计检查
- [ ] 架构风格已选择并有量化理由
- [ ] 技术栈完整且版本明确
- [ ] 模块职责清晰无循环依赖
- [ ] 非功能需求有具体实现方案和指标(避免"高性能"等模糊词)
- [ ] 部署架构可执行
- [ ] 文档结构完整，内容量化

### ADR 检查
- [ ] 重要架构决策已记录 ADR
- [ ] ADR 包含背景、决策、理由、后果
- [ ] 替代方案已列出并说明否决原因

### ATAM 检查（大型项目）
- [ ] 质量属性场景已定义
- [ ] 敏感点和权衡点已识别
- [ ] 风险已评估并有应对措施

## 红灯信号

以下任一出现，立即停止:
- 架构选择没有量化依据(如"因为流行"选择微服务)
- 技术选型团队完全不熟悉
- 模块存在循环依赖
- 非功能需求使用模糊词汇(如"高性能"、"高可用")
- 重要决策无 ADR 记录

---

## 相关资源

### 相关Skills
- [techdesign-02-process](mdc:skills/techdesign-02-process/SKILL.md) - 业务流程设计
- [techdesign-03-feature](mdc:skills/techdesign-03-feature/SKILL.md) - 功能详细设计
- [techdesign-05-database](mdc:skills/techdesign-05-database/SKILL.md) - 数据库设计
- [techdesign-06-api](mdc:skills/techdesign-06-api/SKILL.md) - API接口设计

### 技术栈参考
- [技术栈索引](mdc:.codebuddy/spec/global/knowledge/stack/index.md)
- [Spring Boot 3](mdc:.codebuddy/spec/global/knowledge/stack/springboot3.md)
- [MyBatis-Plus](mdc:.codebuddy/spec/global/knowledge/stack/mybatis_plus.md)
- [Vue 3](mdc:.codebuddy/spec/global/knowledge/stack/vue3.md)

### 规范文档
- [通用规范](mdc:.codebuddy/spec/global/standards/common/index.md)
- [数据库设计规范](mdc:.codebuddy/spec/global/standards/backend/common/database-fields.md)
- [索引设计指南](mdc:.codebuddy/spec/global/standards/backend/common/index-design-guide.md)
