# 系统架构设计 - 使用示例

本文档提供 `design-architect` skill 的实际使用示例，涵盖不同规模和类型的项目架构设计场景。

---

## 示例 1: 电商系统架构设计（微服务架构）

### 用户输入
```
为一个中型电商平台设计系统架构：
- 用户注册登录、商品浏览、下单支付、订单管理
- 预计日活 10 万，高峰期 QPS 5000
- 团队规模 50 人，分为用户、商品、订单、支付 4 个小组
- 需要支持未来 3 年业务增长
```

### AI 执行流程

**步骤 1: 选择架构风格**
```markdown
## 架构风格决策

**选择**: 微服务架构

**理由**:
- 系统规模: 4 个核心业务领域，预计扩展到 8-10 个服务
- 团队规模: 50 人，适合按服务拆分团队
- 性能要求: 高峰期 QPS 5000，需要独立扩展
- 扩展性要求: 业务快速增长，需要横向扩展能力

**权衡**:
优点: 
- 各服务独立部署，故障隔离
- 技术栈灵活，可按需选型
- 团队并行开发，效率高

缺点: 
- 运维复杂度高
- 分布式事务处理复杂

应对措施: 
- 使用 K8s 统一容器编排
- 采用 Saga 模式处理分布式事务
```

**步骤 2: 技术选型**
```markdown
## 技术选型决策

### 后端技术栈
- 编程语言: Java 17
- 后端框架: Spring Boot 3.2 + Spring Cloud
- ORM: MyBatis-Plus 3.5（复杂查询多，需要灵活性）
- 数据库: MySQL 8.0（主）+ Redis 7.x（缓存）
- 消息队列: Kafka 3.x（订单异步处理）
- 服务注册: Nacos 2.x
- API 网关: Spring Cloud Gateway

### 前端技术栈
- 前端框架: Vue 3
- UI 组件库: TDesign
- 构建工具: Vite

### 选型理由
- Spring Boot/Cloud: 团队熟悉，生态成熟，适合微服务
- MyBatis-Plus: 灵活性高，性能优于 JPA，团队有使用经验
- MySQL: 通用场景，社区支持好，运维经验丰富
- Kafka: 高吞吐量，适合订单处理场景
- Vue 3: Composition API 强大，TypeScript 支持完善，中大型项目适用
```

**步骤 3: 服务划分**
```markdown
## 服务划分

### 用户服务 (user-service)
**职责**:
- 用户注册、登录（JWT）
- 用户信息管理（CRUD）
- 用户认证和授权（RBAC）

**对外接口**:
- POST /api/users/register - 用户注册
- POST /api/users/login - 用户登录
- GET /api/users/{id} - 获取用户信息

**数据存储**: user_db（MySQL）
**依赖**: 无（基础服务）
**被依赖**: 订单服务、支付服务

---

### 商品服务 (product-service)
**职责**:
- 商品信息管理（CRUD）
- 商品分类管理
- 库存管理

**对外接口**:
- GET /api/products - 商品列表（分页、筛选）
- GET /api/products/{id} - 商品详情
- PUT /api/products/{id}/stock - 更新库存（内部接口）

**数据存储**: product_db（MySQL）+ Redis（商品详情缓存）
**依赖**: 无
**被依赖**: 订单服务

---

### 订单服务 (order-service)
**职责**:
- 订单创建、查询
- 订单状态管理
- 订单超时取消

**对外接口**:
- POST /api/orders - 创建订单
- GET /api/orders/{id} - 订单详情
- PUT /api/orders/{id}/cancel - 取消订单

**数据存储**: order_db（MySQL）
**依赖**: 用户服务、商品服务、支付服务
**被依赖**: 无

---

### 支付服务 (payment-service)
**职责**:
- 支付单创建
- 对接第三方支付（微信、支付宝）
- 支付回调处理

**对外接口**:
- POST /api/payments - 创建支付单
- POST /api/payments/callback - 支付回调（内部）

**数据存储**: payment_db（MySQL）
**依赖**: 订单服务
**被依赖**: 订单服务
```

**步骤 4: 非功能需求实现**
```markdown
## 性能优化

### 多级缓存
L1 缓存: 本地缓存（Caffeine）- 商品分类、热门商品，容量 5000 条，过期 5 分钟
L2 缓存: Redis - 商品详情、用户会话，过期 30 分钟
L3 存储: MySQL - 持久化存储

### 数据库优化
索引设计:
- 订单表: order_no（唯一索引）、user_id + create_time（联合索引）
- 商品表: category_id + status（联合索引）

读写分离:
- 主库: 写操作
- 从库 2 个: 读操作（轮询）

分库分表:
- 订单表按用户 ID 取模分 16 库
- 触发条件: 单表 > 1000 万行

### 负载均衡
Spring Cloud Gateway
- 算法: 轮询
- 健康检查: 每 10 秒检测，3 次失败剔除

---

## 高可用方案

### 应用层
- 多实例部署: 每个服务最少 3 个实例
- 自动扩缩容: CPU > 70% 扩容，< 30% 缩容
- K8s: 自动重启故障容器，30 秒内完成

### 数据层
- MySQL: 1 主 2 从，半同步复制
- 故障转移: < 30 秒
- 数据备份: 全量备份每天凌晨 2 点，增量备份每小时，保留 30 天

### 监控告警
系统监控: Prometheus + Grafana
- CPU > 80%、内存 > 90%、磁盘 > 85% 告警

应用监控:
- 错误率 > 1%、响应时间 P95 > 500ms 告警

业务监控:
- 订单量异常下降 > 20%、支付成功率 < 95% 告警

---

## 安全防护

### 认证授权
- JWT Token: 访问令牌 2 小时，刷新令牌 7 天
- RBAC: 基于角色的权限控制

### 数据安全
- 传输加密: HTTPS（TLS 1.2+）
- 存储加密: 密码 BCrypt，敏感字段 AES-256
- 数据脱敏: 日志、显示、导出时自动脱敏

### 攻击防护
- SQL 注入: MyBatis 参数化查询（#{}）
- XSS: HTML 转义，CSP 策略
- DDoS: 单 IP 限制 100 QPS，WAF
- 暴力破解: 5 次失败锁定 15 分钟
```

**步骤 5: 部署架构**
```markdown
## 部署架构

### 环境划分
- 开发环境（Dev）: 本地开发，Docker Compose
- 测试环境（Test）: Kubernetes，2 核 4G
- 预发环境（Staging）: Kubernetes，4 核 8G
- 生产环境（Prod）: Kubernetes，8 核 16G，3 实例

### CI/CD 流程
持续集成（CI）:
1. 代码提交 → GitLab CI 自动构建
2. Maven 编译打包
3. 单元测试（覆盖率 > 80%）
4. SonarQube 质量检查
5. 推送镜像到 Harbor

持续部署（CD）:
1. 测试环境自动部署
2. 生产环境灰度发布（10% → 50% → 100%）
3. 异常自动回滚（错误率 > 1%）

### 日志和监控
- 日志: Filebeat → Elasticsearch → Kibana
- 监控: Prometheus → Grafana
- 链路追踪: SkyWalking

### 灾备方案
备份策略:
- 全量备份: 每天凌晨 2 点
- 增量备份: 每小时
- Binlog 备份: 实时

RTO: 30 分钟内恢复服务
RPO: 数据损失 < 5 分钟
```

---

## 示例 2: 企业内部管理系统（单体架构）

### 用户输入
```
为一个企业内部 OA 系统设计架构：
- 功能: 考勤、请假、报销、审批流
- 用户规模: 500 人
- 团队: 5 人开发团队
- 需要快速上线（3 个月）
```

### AI 执行流程

**步骤 1: 选择架构风格**
```markdown
## 架构风格决策

**选择**: 单体架构

**理由**:
- 系统规模: 4 个核心模块，功能边界清晰
- 团队规模: 5 人，微服务运维成本过高
- 开发周期: 3 个月，单体架构开发效率高
- 用户规模: 500 人，单体架构性能足够

**权衡**:
优点: 
- 开发简单，调试方便
- 部署简单，运维成本低
- 事务处理简单（本地事务）

缺点: 
- 扩展性受限
- 模块耦合风险

应对措施: 
- 严格模块划分，避免循环依赖
- 预留微服务化演进接口
```

**步骤 2: 技术选型**
```markdown
## 技术选型决策

### 后端技术栈
- 编程语言: Java 17
- 后端框架: Spring Boot 3.2
- ORM: MyBatis-Plus 3.5
- 数据库: MySQL 8.0
- 缓存: Redis 7.x（可选，后期优化）

### 前端技术栈
- 前端框架: Vue 3
- UI 组件库: TDesign
- 构建工具: Vite

### 选型理由
- Spring Boot: 快速开发，内置 Tomcat，易于部署
- MyBatis-Plus: 减少 CRUD 代码，提高开发效率
- MySQL: 团队熟悉，运维简单
- Vue 3: 学习曲线平缓，中小型项目首选
- TDesign: 腾讯企业级设计，符合内部系统风格
```

**步骤 3: 模块划分**
```markdown
## 模块划分

src/main/java/com/company/oa/
├── user/              # 用户模块
│   ├── controller/
│   ├── service/
│   ├── mapper/
│   └── entity/
├── attendance/        # 考勤模块
├── leave/             # 请假模块
├── expense/           # 报销模块
├── workflow/          # 审批流模块
└── common/            # 通用模块
    ├── auth/          # 认证授权
    ├── notification/  # 通知
    └── file/          # 文件管理

### 用户模块
**职责**:
- 员工信息管理
- 组织架构管理
- 角色权限管理

**对外接口**:
- GET /api/users - 员工列表
- POST /api/users - 新增员工

**依赖**: 无
**被依赖**: 所有业务模块

### 审批流模块
**职责**:
- 审批流程定义
- 审批任务分配
- 审批状态管理

**对外接口**:
- POST /api/workflows - 发起审批
- PUT /api/workflows/{id}/approve - 审批通过
- PUT /api/workflows/{id}/reject - 审批拒绝

**依赖**: 用户模块
**被依赖**: 请假模块、报销模块
```

**步骤 4: 非功能需求实现**
```markdown
## 性能优化

### 数据库优化
索引设计:
- 审批流表: workflow_id（主键）、user_id + status（联合索引）
- 考勤表: user_id + date（联合索引）

### 缓存策略（后期优化）
- 用户信息缓存（Redis，过期 30 分钟）
- 组织架构缓存（Redis，过期 1 小时）

---

## 高可用方案

### 应用层
- 双实例部署（主备）
- Nginx 负载均衡

### 数据层
- MySQL: 1 主 1 从
- 数据备份: 全量备份每天，保留 7 天

---

## 安全防护

### 认证授权
- JWT Token: 访问令牌 8 小时
- RBAC: 角色权限控制

### 数据安全
- HTTPS 传输
- 密码 BCrypt 加密
- 操作日志记录
```

**步骤 5: 部署架构**
```markdown
## 部署架构

### 环境划分
- 开发环境: 本地开发
- 测试环境: 单台云服务器（4 核 8G）
- 生产环境: 双机部署（8 核 16G）

### CI/CD 流程
- 代码提交 → GitLab CI
- Maven 打包 → JAR 文件
- 手动部署到服务器
- Nginx 切换流量

### 监控
- 应用监控: Spring Boot Actuator
- 日志: 本地文件 + ELK（后期）
```

---

## 示例 3: Serverless 架构（活动营销系统）

### 用户输入
```
为一个短期营销活动设计架构：
- 功能: 抽奖、优惠券发放、活动统计
- 活动周期: 1 周
- 预计流量: 平时 100 QPS，高峰期 5000 QPS
- 快速上线，活动结束后下线
```

### AI 执行流程

**步骤 1: 选择架构风格**
```markdown
## 架构风格决策

**选择**: Serverless 架构

**理由**:
- 活动周期短（1 周），不需要长期运维
- 流量波动大（100 - 5000 QPS），需要弹性扩展
- 快速上线要求（无需管理服务器）
- 成本敏感（按使用付费）

**权衡**:
优点: 
- 自动扩缩容，应对流量突增
- 按使用付费，成本可控
- 运维成本极低

缺点: 
- 冷启动延迟（首次调用 500ms）
- 调试困难

应对措施: 
- 预热函数避免冷启动
- 使用云平台日志服务
```

**步骤 2: 技术选型**
```markdown
## 技术选型决策

### Serverless 平台
- 云平台: 腾讯云 SCF（云函数）
- 运行时: Node.js 18

### 后端技术栈
- 框架: Express.js（轻量级）
- ORM: Prisma（类型安全）
- 数据库: 腾讯云 MySQL Serverless
- 缓存: Redis Serverless
- 对象存储: COS（活动素材）

### 前端技术栈
- 框架: Vue 3
- 托管: 腾讯云静态网站托管
- CDN: 腾讯云 CDN

### 选型理由
- SCF: 自动扩展，按调用次数付费
- MySQL Serverless: 按使用付费，无需管理
- Node.js: 启动快，适合 Serverless
- COS: 素材存储，CDN 加速
```

**步骤 3: 函数划分**
```markdown
## 函数划分

### 抽奖函数 (lottery-function)
**职责**: 处理抽奖逻辑

**触发方式**: API 网关（POST /api/lottery）

**执行流程**:
1. 验证用户资格
2. 随机抽奖
3. 扣减库存（Redis 原子操作）
4. 记录中奖信息

**配置**:
- 内存: 512MB
- 超时: 10 秒
- 并发: 1000

---

### 优惠券函数 (coupon-function)
**职责**: 优惠券发放和查询

**触发方式**: API 网关（POST /api/coupons）

**配置**:
- 内存: 256MB
- 超时: 5 秒
- 并发: 500

---

### 统计函数 (stats-function)
**职责**: 活动数据统计

**触发方式**: 定时触发（每 10 分钟）

**配置**:
- 内存: 1024MB
- 超时: 60 秒
```

**步骤 4: 非功能需求实现**
```markdown
## 性能优化

### 缓存策略
- Redis 缓存抽奖库存（原子递减）
- CDN 缓存静态资源（过期 1 天）

### 数据库优化
- 读写分离（Serverless MySQL 自动支持）
- 连接池复用（减少冷启动开销）

---

## 高可用方案

### 应用层
- 自动扩缩容: SCF 自动扩展到 1000 并发
- 多可用区部署

### 数据层
- MySQL Serverless: 自动备份
- Redis Serverless: 主从复制

---

## 安全防护

### 认证授权
- 微信 OAuth 登录
- Token 验证

### 攻击防护
- API 网关限流: 单用户 10 QPS
- 验证码防刷
```

**步骤 5: 部署架构**
```markdown
## 部署架构

### 环境划分
- 测试环境: SCF 测试命名空间
- 生产环境: SCF 生产命名空间

### CI/CD 流程
- 代码提交 → GitHub Actions
- npm 打包
- 上传到 SCF

### 监控
- 云监控: 函数调用次数、错误率、延迟
- 日志: 云日志服务

### 成本预估
- 函数调用: 100 万次/天 × 7 天 = 700 万次（约 100 元）
- 数据库: Serverless 按使用（约 50 元）
- 总成本: 约 150 元
```

---

## 示例 4: 技术演进场景（单体迁移微服务）

### 用户输入
```
现有单体系统需要微服务化改造：
- 当前: Spring Boot 单体应用，8 个模块
- 问题: 部署慢（30 分钟）、故障影响全局、团队协作困难
- 团队: 30 人，分 4 个小组
- 要求: 逐步迁移，不停机
```

### AI 执行流程

**步骤 1: 评估拆分必要性**
```markdown
## 微服务化评估

**拆分理由**:
- 部署效率问题: 单次部署 30 分钟，影响迭代速度
- 故障隔离需求: 单点故障影响整体
- 团队规模: 30 人，适合微服务拆分
- 业务复杂度: 8 个模块，可独立拆分

**拆分策略**: 渐进式拆分（绞杀者模式）

**时间规划**:
- 第 1-2 月: 基础设施搭建（注册中心、网关、监控）
- 第 3-4 月: 拆分用户服务、订单服务
- 第 5-6 月: 拆分商品服务、支付服务
- 第 7-8 月: 剩余模块拆分、单体下线
```

**步骤 2: 拆分顺序**
```markdown
## 拆分优先级

### 第一批: 独立性强的服务
1. **用户服务**: 依赖少，被依赖多，基础服务
2. **通知服务**: 完全独立，无依赖

### 第二批: 核心业务服务
3. **订单服务**: 核心业务，拆分后性能提升明显
4. **支付服务**: 高可用要求，需要独立扩展

### 第三批: 辅助服务
5. **商品服务**: 依赖少
6. **营销服务**: 流量波动大，需要独立扩展

### 保留单体
7. **报表服务**: 跨多个服务查询，保留在单体或最后拆分
```

**步骤 3: 迁移方案**
```markdown
## 绞杀者模式迁移

### 基础设施准备
1. **服务注册中心**: Nacos
2. **API 网关**: Spring Cloud Gateway
3. **配置中心**: Nacos Config
4. **链路追踪**: SkyWalking

### 单个服务迁移步骤

**以用户服务为例**:

1. **代码拆分**
   - 从单体中复制 user 模块代码
   - 创建独立 user-service 项目
   - 配置独立数据库连接

2. **双写阶段**
   - 单体和微服务同时写入数据库
   - 确保数据一致性

3. **灰度切流**
   - API 网关路由 10% 流量到新服务
   - 观察日志、监控指标
   - 逐步提升到 50%、100%

4. **下线单体模块**
   - 确认新服务稳定运行 1 周
   - 删除单体中的 user 模块代码
   - 清理数据库双写逻辑

### 数据迁移
- **数据库拆分**: 逐步拆分，先逻辑隔离，后物理拆分
- **数据同步**: Binlog 同步，保证一致性
- **回滚方案**: 保留单体数据库 1 个月
```

**步骤 4: 风险控制**
```markdown
## 风险控制

### 灰度发布
- 10% → 50% → 100%，每阶段观察 1 天
- 自动回滚: 错误率 > 1% 或响应时间 > 1 秒

### 数据一致性
- 双写期间定时对账
- 发现不一致立即告警

### 监控告警
- 调用量对比（单体 vs 微服务）
- 错误率、响应时间实时监控
- 数据一致性检查

### 回滚方案
- 保留单体代码和数据库 1 个月
- API 网关快速切回单体（< 5 分钟）
```

---

## 总结

以上示例涵盖了常见的架构设计场景：

1. **微服务架构**: 适合大中型系统、团队规模大、业务复杂
2. **单体架构**: 适合中小型系统、快速上线、团队规模小
3. **Serverless**: 适合短期活动、流量波动大、成本敏感
4. **技术演进**: 单体迁移微服务，渐进式改造

每个示例都遵循了 `design-architect` skill 的核心原则：
- 架构风格有量化依据
- 技术选型考虑团队熟悉度
- 模块划分清晰无循环依赖
- 非功能需求具体量化
- 部署架构可执行
