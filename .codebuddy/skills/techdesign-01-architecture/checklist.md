# 系统架构设计 - 验证清单

本清单用于验证 `design-architect` skill 的输出质量，确保架构设计符合最佳实践和项目规范。

---

## 📋 前置条件检查

在开始架构设计前，确认以下条件已满足：

- [ ] 需求文档已存在: `workspace/{变更ID}/requirements/requirements.md`
- [ ] 功能需求已明确（核心功能清单、用户角色、使用场景）
- [ ] 非功能需求已量化（性能指标、可用性要求、安全要求）
- [ ] 技术约束已确定（技术栈限制、团队技能、现有系统）
- [ ] 项目规模已明确（用户规模、数据量、并发量）

---

## 🎯 架构风格决策质量检查

### 必须项（红线）

- [ ] **架构风格已选择** - 明确选择单体/微服务/Serverless
- [ ] **决策有量化依据** - 基于系统规模、团队规模、性能要求等具体数据
- [ ] **避免盲目跟风** - 不因"流行"而选择微服务，不因"简单"而固守单体
- [ ] **考虑团队能力** - 团队对所选架构有足够的技术储备和运维能力

### 质量标准

- [ ] 系统规模量化（模块数量、服务数量）
- [ ] 团队规模明确（开发人员数量、团队结构）
- [ ] 性能指标具体（QPS、并发量、响应时间）
- [ ] 扩展性需求清晰（业务增长预期、流量增长预期）
- [ ] 权衡分析完整（优点、缺点、应对措施）

### 红灯信号（立即停止）

- [ ] ❌ 使用"因为流行"作为架构选择理由
- [ ] ❌ 小型项目（<5 人团队）选择微服务且无充分理由
- [ ] ❌ 未考虑团队技术能力就选择新架构
- [ ] ❌ 架构选择与业务规模严重不匹配

---

## 🛠️ 技术选型质量检查

### 必须项（红线）

- [ ] **技术栈完整** - 后端、前端、数据库、中间件全部明确
- [ ] **版本明确** - 所有技术组件指定具体版本号
- [ ] **团队熟悉度评估** - 确认团队对所选技术有使用经验
- [ ] **选型理由清晰** - 每个技术选择都有明确的理由

### 质量标准

#### 后端技术栈
- [ ] 编程语言及版本（如 Java 17、Node.js 18）
- [ ] 后端框架及版本（如 Spring Boot 3.2、Express.js）
- [ ] ORM 框架及版本（如 MyBatis-Plus 3.5、Prisma）
- [ ] 数据库及版本（如 MySQL 8.0、PostgreSQL 14）
- [ ] 缓存及版本（如 Redis 7.x）
- [ ] 消息队列及版本（如 Kafka 3.x、RabbitMQ 3.x）

#### 前端技术栈
- [ ] 前端框架及版本（如 Vue 3.4）
- [ ] UI 组件库（如 Ant Design、TDesign）
- [ ] 构建工具（如 Vite、Webpack）

#### 选型理由包含
- [ ] 团队熟悉度（有/无使用经验）
- [ ] 性能表现（是否满足性能要求）
- [ ] 生态成熟度（社区支持、文档完善度）
- [ ] 长期维护性（是否有持续更新）

### 红灯信号（立即停止）

- [ ] ❌ 技术栈缺少版本号
- [ ] ❌ 团队完全不熟悉所选技术
- [ ] ❌ 选择过时或停止维护的技术
- [ ] ❌ 选型理由模糊（如"听说很好用"）

---

## 🧩 模块/服务划分质量检查

### 必须项（红线）

- [ ] **职责边界清晰** - 每个模块/服务的职责明确、单一
- [ ] **无循环依赖** - 依赖关系为单向，不存在 A ↔ B 的双向依赖
- [ ] **接口定义完整** - 每个模块对外提供的接口已定义
- [ ] **数据边界清晰** - 每个模块的数据存储边界明确（单体架构）或服务独立数据库（微服务）

### 质量标准

#### 单体架构模块划分
- [ ] 按业务领域划分，不按技术层划分（✅ user/order/product，❌ controller/service/dao）
- [ ] 模块目录结构清晰（controller、service、mapper、entity）
- [ ] 模块间依赖关系明确（哪些模块依赖、哪些被依赖）
- [ ] 公共模块职责明确（common、utils、config）

#### 微服务架构服务划分
- [ ] 服务名称清晰（user-service、order-service）
- [ ] 服务职责明确（2-3 句话描述清楚）
- [ ] 服务对外接口完整（HTTP API 列表）
- [ ] 服务数据存储独立（独立数据库）
- [ ] 服务依赖关系清晰（依赖哪些服务、被哪些依赖）

#### 依赖关系检查
- [ ] 绘制依赖关系图（可视化检查循环依赖）
- [ ] 基础服务无依赖（如 user-service）
- [ ] 业务服务依赖基础服务（单向依赖）
- [ ] 避免相互依赖（✅ A→B，❌ A↔B）

### 红灯信号（立即停止）

- [ ] ❌ 存在循环依赖（A 依赖 B，B 依赖 A）
- [ ] ❌ 模块职责不清晰（"这个模块做什么？"无法简短回答）
- [ ] ❌ 单体架构按技术层划分（controller、service、dao）
- [ ] ❌ 微服务粒度过细（单个接口拆成一个服务）
- [ ] ❌ 微服务粒度过粗（所有功能在一个服务）

---

## ⚡ 非功能需求实现质量检查

### 必须项（红线）

- [ ] **所有指标量化** - 避免"高性能"、"高可用"等模糊词汇
- [ ] **实现方案具体** - 不只是列出技术名称，要说明如何使用
- [ ] **配置参数明确** - 缓存过期时间、连接池大小、超时时间等参数具体
- [ ] **监控告警阈值明确** - CPU > X%、错误率 > Y% 等具体数值

### 性能优化检查

#### 缓存策略
- [ ] 缓存层级明确（L1/L2/L3，本地/Redis/数据库）
- [ ] 缓存内容明确（缓存什么数据）
- [ ] 缓存容量明确（如 10000 条）
- [ ] 缓存过期时间明确（如 5 分钟、30 分钟、24 小时）
- [ ] 缓存更新策略明确（失效、主动更新）

#### 数据库优化
- [ ] 索引设计完整（主键、唯一、普通索引）
- [ ] 索引字段明确（user_id、create_time 等）
- [ ] 读写分离方案明确（主库写、从库读）
- [ ] 分库分表触发条件明确（如单表 > 1000 万行）
- [ ] 分库分表策略明确（按 ID 取模、按时间分片）

#### 负载均衡
- [ ] 负载均衡器明确（Nginx、HAProxy、LB）
- [ ] 负载均衡算法明确（轮询、最少连接、IP Hash）
- [ ] 健康检查配置明确（检测间隔、失败阈值）

### 高可用方案检查

#### 应用层
- [ ] 实例数量明确（如最少 2 个、推荐 3-5 个）
- [ ] 扩缩容策略明确（CPU > 70% 扩容、< 30% 缩容）
- [ ] 故障转移时间明确（如 < 30 秒）
- [ ] 容器编排方案明确（Kubernetes、Docker Swarm）

#### 数据层
- [ ] 主从配置明确（1 主 2 从）
- [ ] 同步模式明确（异步、半同步、同步）
- [ ] 故障转移时间明确（如 < 30 秒）
- [ ] 备份策略明确（全量、增量、时间点）
- [ ] 备份保留策略明确（保留 7 天、30 天）

#### 监控告警
- [ ] 监控工具明确（Prometheus、Grafana、SkyWalking）
- [ ] 系统监控指标明确（CPU、内存、磁盘、网络）
- [ ] 应用监控指标明确（错误率、响应时间、QPS）
- [ ] 业务监控指标明确（订单量、支付成功率）
- [ ] 告警阈值具体（CPU > 80%、错误率 > 1%、P95 > 500ms）
- [ ] 告警方式明确（邮件、短信、钉钉、企业微信）

### 安全防护检查

#### 认证授权
- [ ] 认证方式明确（JWT、Session、OAuth）
- [ ] Token 过期时间明确（访问令牌 2 小时、刷新令牌 7 天）
- [ ] 权限模型明确（RBAC、ABAC）

#### 数据安全
- [ ] 传输加密明确（HTTPS、TLS 版本）
- [ ] 存储加密明确（密码 BCrypt、敏感字段 AES-256）
- [ ] 数据脱敏规则明确（日志、显示、导出场景）

#### 攻击防护
- [ ] SQL 注入防护（参数化查询、ORM）
- [ ] XSS 防护（HTML 转义、CSP 策略）
- [ ] CSRF 防护（CSRF Token、SameSite Cookie）
- [ ] DDoS 防护（CDN、WAF、IP 限流）
- [ ] 暴力破解防护（失败次数限制、锁定时间）
- [ ] 限流策略明确（单 IP/单用户 X QPS）

### 扩展性方案检查

- [ ] 横向扩展能力（无状态设计、容器化）
- [ ] 垂直扩展能力（资源配置、性能优化）
- [ ] 自动扩缩容配置（HPA、Auto Scaling）

### 红灯信号（立即停止）

- [ ] ❌ 使用"高性能"、"高可用"、"高并发"等模糊词汇
- [ ] ❌ 缓存策略缺少过期时间
- [ ] ❌ 监控告警缺少具体阈值
- [ ] ❌ 备份策略缺少时间点和保留期
- [ ] ❌ 扩缩容策略缺少触发条件

---

## 🚀 部署架构质量检查

### 必须项（红线）

- [ ] **环境划分明确** - 开发、测试、预发、生产环境配置
- [ ] **CI/CD 流程完整** - 构建、测试、部署、回滚流程
- [ ] **监控日志方案明确** - 日志收集、存储、查询方案
- [ ] **灾备方案可执行** - RTO/RPO 明确，恢复步骤清晰

### 环境划分检查

- [ ] 开发环境配置（本地/Docker Compose）
- [ ] 测试环境配置（服务器配置、资源规格）
- [ ] 预发环境配置（生产镜像、灰度验证）
- [ ] 生产环境配置（高可用、多实例、资源规格）

### CI/CD 流程检查

#### 持续集成（CI）
- [ ] 代码提交触发构建
- [ ] 编译打包工具明确（Maven、Gradle、npm）
- [ ] 自动化测试（单元测试、集成测试、覆盖率要求）
- [ ] 质量检查工具（SonarQube、ESLint）
- [ ] 镜像仓库明确（Harbor、Docker Hub）

#### 持续部署（CD）
- [ ] 测试环境部署策略（自动/手动）
- [ ] 生产环境部署策略（灰度、蓝绿、金丝雀）
- [ ] 灰度发布比例明确（10% → 50% → 100%）
- [ ] 回滚触发条件明确（错误率、响应时间）
- [ ] 回滚时间要求明确（如 < 5 分钟）

#### 工具链
- [ ] 代码托管（GitLab、GitHub、Gitee）
- [ ] CI/CD 工具（GitLab CI、GitHub Actions、Jenkins）
- [ ] 容器编排（Kubernetes、Docker Swarm）
- [ ] 部署工具（ArgoCD、Helm、Ansible）

### 日志和监控检查

#### 日志方案
- [ ] 日志收集工具（Fluentd、Filebeat、Logstash）
- [ ] 日志存储（Elasticsearch、云日志服务）
- [ ] 日志查询界面（Kibana、云控制台）
- [ ] 日志保留策略（保留 7 天、30 天）

#### 监控方案
- [ ] 监控工具（Prometheus、Grafana、云监控）
- [ ] 监控指标完整（系统、应用、业务）
- [ ] 告警规则明确（阈值、告警方式）

#### 链路追踪
- [ ] 链路追踪工具（SkyWalking、Zipkin、Jaeger）
- [ ] 采样率配置（如 10%、100%）

### 灾备方案检查

#### 备份策略
- [ ] 备份类型明确（全量、增量、Binlog）
- [ ] 备份时间明确（每天凌晨、每小时）
- [ ] 备份保留策略明确（7 天、30 天、12 月）
- [ ] 备份验证机制（定期恢复测试）

#### 恢复指标
- [ ] RTO 明确（Recovery Time Objective，如 30 分钟）
- [ ] RPO 明确（Recovery Point Objective，如数据损失 < 5 分钟）
- [ ] 恢复步骤清晰（可操作的恢复流程）

### 红灯信号（立即停止）

- [ ] ❌ 缺少灰度发布策略
- [ ] ❌ 缺少自动化回滚机制
- [ ] ❌ RTO/RPO 未明确
- [ ] ❌ 日志保留策略缺失
- [ ] ❌ 备份恢复未经过演练

---

## 📄 架构文档质量检查

### 文档结构完整性

- [ ] 架构概述（架构风格、架构图、关键决策）
- [ ] 技术选型（技术栈清单、版本、理由）
- [ ] 模块/服务划分（清单、职责、依赖关系）
- [ ] 非功能需求实现（性能、可用性、安全、扩展）
- [ ] 部署架构（部署方式、CI/CD、监控、灾备）
- [ ] 架构演进计划（局限性、演进方向、计划）

### 文档质量标准

- [ ] 所有指标量化（避免模糊词汇）
- [ ] 架构图清晰（组件、连接、数据流）
- [ ] 决策有依据（为什么选择这个方案）
- [ ] 可执行性强（开发团队能直接使用）
- [ ] 易于维护（结构清晰、更新方便）

### 输出路径规范

- [ ] 文档路径正确: `workspace/{变更ID}/design/architecture.md`
- [ ] 遵循文档生成原则（只在用户明确要求时生成）

---

## ✅ 最终验收清单

在交付架构设计前，确认以下所有项：

### 核心质量（必须全部通过）

- [ ] 架构风格有量化决策依据
- [ ] 技术栈完整且版本明确
- [ ] 模块职责清晰无循环依赖
- [ ] 非功能需求全部量化（无"高性能"等模糊词）
- [ ] 部署架构可执行
- [ ] 文档结构完整

### 可执行性（必须全部通过）

- [ ] 开发团队能理解并执行
- [ ] 技术栈团队有使用经验
- [ ] 部署流程可落地
- [ ] 监控方案可实施

### 前瞻性（推荐通过）

- [ ] 架构有演进空间
- [ ] 考虑未来 1-2 年业务增长
- [ ] 有明确的优化方向

---

## 🚨 常见问题自查

### 架构风格选择

- [ ] 是否过度设计？（小项目选择微服务）
- [ ] 是否架构不足？（大项目坚持单体）
- [ ] 是否盲目跟风？（因为"流行"而选择）

### 技术选型

- [ ] 是否选择团队完全不熟悉的技术？
- [ ] 是否选择停止维护的技术？
- [ ] 是否版本过新或过旧？

### 模块划分

- [ ] 是否存在循环依赖？
- [ ] 是否模块职责不清？
- [ ] 是否粒度过细或过粗？

### 非功能需求

- [ ] 是否所有指标都量化了？
- [ ] 是否缺少监控告警阈值？
- [ ] 是否缺少备份恢复策略？

### 部署架构

- [ ] 是否缺少灰度发布策略？
- [ ] 是否缺少自动回滚机制？
- [ ] 是否缺少日志监控方案？

---

## 📊 评分标准

使用以下标准评估架构设计质量：

### 优秀（90-100 分）
- ✅ 所有必须项通过
- ✅ 所有质量标准满足
- ✅ 无红灯信号
- ✅ 文档完整、量化、可执行

### 良好（80-89 分）
- ✅ 所有必须项通过
- ✅ 大部分质量标准满足
- ⚠️ 少量优化项待完善

### 合格（70-79 分）
- ✅ 必须项通过
- ⚠️ 部分质量标准待优化
- ⚠️ 需要补充细节

### 不合格（< 70 分）
- ❌ 存在红灯信号
- ❌ 必须项未全部通过
- ❌ 需要重新设计

---

## 🔄 持续改进

架构设计是一个持续演进的过程：

- [ ] 定期评审架构（季度/半年）
- [ ] 根据业务变化调整架构
- [ ] 收集团队反馈优化设计
- [ ] 记录架构决策和演进历史
