# 功能详细设计参考资料和最佳实践

本文档提供功能设计的参考资料、模板和最佳实践。

---

## 1. 功能分解模板

### 1.1 功能树结构

```
功能模块: {模块名称}
├─ 功能 1: {功能名称}（优先级: P0/P1/P2/P3）
│  ├─ 子功能 1.1: {子功能名称}
│  │  ├─ 步骤 1: {操作描述}
│  │  ├─ 步骤 2: {操作描述}
│  │  └─ 步骤 3: {操作描述}
│  ├─ 子功能 1.2: {子功能名称}
│  │  └─ ...
│  └─ 子功能 1.3: {子功能名称}
│     └─ ...
├─ 功能 2: {功能名称}（优先级: P0/P1/P2/P3）
│  └─ ...
└─ 功能 3: {功能名称}（优先级: P0/P1/P2/P3）
   └─ ...
```

### 1.2 优先级定义

```
P0 (必须): 核心功能，系统无法运行缺少此功能
  - 示例: 用户登录、创建订单、支付订单

P1 (重要): 重要功能，影响用户体验但不影响系统运行
  - 示例: 手机号验证码登录、订单取消、退款

P2 (可选): 可选功能，提升用户体验
  - 示例: 第三方登录、订单评论、商品收藏

P3 (增强): 增强功能，锦上添花
  - 示例: 生物识别登录、订单推荐、智能客服
```

---

## 2. 用例设计模板

### 2.1 正常用例模板

```
用例 ID: UC-{MODULE}-{序号}
  - 命名规范: UC（User Case）+ 模块缩写 + 三位序号
  - 示例: UC-LOGIN-001, UC-ORDER-002

用例名称: {用例名称}
  - 简洁描述用例目的
  - 示例: 用户名密码登录、创建订单

参与者: {参与者}
  - 谁执行这个用例
  - 示例: 用户、管理员、系统

前置条件: {前置条件}
  - 执行用例前必须满足的条件
  - 示例: 用户已注册、用户已登录、商品已选择

主流程:
1. {步骤 1 描述}
2. {步骤 2 描述}
3. {步骤 3 描述}
...
n. {步骤 n 描述}

后置条件: {后置条件}
  - 用例执行后的系统状态
  - 示例: 用户已登录、订单已创建、状态为"待支付"
```

### 2.2 异常用例模板

```
异常用例 {序号}: {异常名称}

触发条件: {触发条件}
  - 在主流程的哪一步触发
  - 满足什么条件触发
  - 示例: 步骤 5，用户名在数据库中不存在

处理流程:
1. {处理步骤 1}
2. {处理步骤 2}
3. {处理步骤 3}
...

结果: {结果描述}
  - 异常处理后的结果
  - 示例: 登录失败，用户停留在登录页面
```

### 2.3 边界用例模板

```
边界用例 {序号}: {边界名称}

触发条件: {触发条件}
  - 什么情况下触发
  - 示例: 用户名长度 > 50 字符

处理: {处理方式}
  - 如何处理这个边界情况
  - 示例: 前端限制输入长度，后端返回"用户名长度不能超过 50 字符"

结果: {结果描述}
  - 边界处理后的结果
  - 示例: 无法提交或后端拒绝
```

---

## 3. 输入输出定义模板

### 3.1 输入字段模板

```
{字段名} ({中文名称})
├─ 类型: {数据类型}
│  - 可选: String, Integer, Decimal, Boolean, Date, DateTime, Array, Object
├─ 长度: {长度限制}（仅字符串）
│  - 示例: 1-50 字符
├─ 格式: {格式要求}
│  - 示例: 字母、数字、下划线
├─ 必填: {是否必填}
│  - 可选: 是、否
├─ 默认值: {默认值}
│  - 如果可选，提供默认值
├─ 示例: {示例值}
│  - 提供真实的示例值
└─ 验证规则:
   ├─ 非空检查（如果必填）
   ├─ 长度检查: {长度范围}
   ├─ 格式检查: {正则表达式或规则描述}
   └─ 业务规则检查: {业务规则描述}
```

### 3.2 成功输出模板

```json
{
  "field1": value1,  // 字段 1 说明
  "field2": value2,  // 字段 2 说明
  "field3": {        // 嵌套对象
    "nested_field1": value,
    "nested_field2": value
  },
  "field4": [        // 数组
    item1,
    item2
  ]
}
```

**字段说明**:
```
field1 (字段 1)
├─ 类型: {类型}
├─ 格式: {格式}
├─ 说明: {说明}
└─ 示例: {示例}
```

### 3.3 失败输出模板

```json
{
  "error_code": 4001,
  "error_message": "用户可读的错误信息",
  "error_details": {
    "field": "具体字段",
    "message": "详细错误信息"
  }
}
```

### 3.4 数据格式规范

```
日期时间格式:
├─ 格式: ISO 8601
├─ 示例: "2025-11-07T10:30:00Z"
├─ 时区: UTC（所有日期时间都用 UTC）
└─ 说明: 前端负责转换为本地时间

布尔值格式:
├─ 格式: true/false（不使用 1/0）
└─ 示例: true, false

数字格式:
├─ 整数: Integer
├─ 小数: Decimal（保留 2 位小数）
└─ 示例: 99.99

字符串格式:
├─ 编码: UTF-8
├─ 特殊字符: HTML 转义（防止 XSS）
└─ 空值: null（不使用 ""）

数组格式:
├─ 空数组: []（不使用 null）
└─ 示例: ["item1", "item2"]
```

---

## 4. 边界条件处理模板

### 4.1 数据边界模板

```
字符串长度边界:
├─ 最小长度: {最小长度}（如 1 字符）
│  └─ 处理: {处理方式}
├─ 最大长度: {最大长度}（如 50 字符）
│  └─ 处理: {处理方式}
├─ 空字符串: {是否允许}
│  └─ 处理: {处理方式}
└─ 超长字符串: {处理方式}
   └─ 处理: 截断或拒绝

数值边界:
├─ 最小值: {最小值}（如 0）
│  └─ 处理: {处理方式}
├─ 最大值: {最大值}（如 999999）
│  └─ 处理: {处理方式}
├─ 负数: {是否允许}
│  └─ 处理: {处理方式}
└─ 小数位数: {位数}（如保留 2 位）
   └─ 处理: 四舍五入

日期时间边界:
├─ 最早日期: {最早日期}（如 1970-01-01）
├─ 最晚日期: {最晚日期}（如 2100-12-31）
├─ 历史日期: {是否允许}
├─ 未来日期: {是否允许}
└─ 时区: {时区}（统一使用 UTC）

集合边界:
├─ 空集合: {是否允许}
├─ 单元素: {是否允许}
├─ 最大元素: {最大元素数}（如 100 个）
└─ 重复元素: {处理方式}（去重或拒绝）
```

### 4.2 并发边界模板

```
{并发场景名称}:
├─ 场景: {场景描述}
│  - 描述并发发生的情况
│  - 示例: 多个用户同时购买最后一件商品
├─ 处理方式:
│  ├─ 方式 1: {处理方式 1}
│  │  - 示例: 乐观锁（使用 version 字段）
│  ├─ 方式 2: {处理方式 2}
│  │  - 示例: 悲观锁（SELECT FOR UPDATE）
│  └─ 方式 3: {处理方式 3}
│     - 示例: 分布式锁（Redis 分布式锁）
└─ 结果: {结果描述}
   - 并发处理后的结果
   - 示例: 只有一个用户成功，其他用户返回"库存不足"
```

### 4.3 性能边界模板

```
响应时间:
├─ 正常响应: < {时间}（如 < 200ms）
│  └─ 目标: {目标描述}（如 P95 响应时间 < 200ms）
├─ 慢查询: {时间范围}（如 200-1000ms）
│  └─ 处理: {处理方式}（如记录慢查询日志，优化 SQL）
├─ 超时: > {时间}（如 > 5000ms）
│  └─ 处理: {处理方式}（如返回"请求超时，请重试"）
└─ 优化策略:
   ├─ 策略 1: {优化策略 1}（如异步处理）
   ├─ 策略 2: {优化策略 2}（如缓存）
   └─ 策略 3: {优化策略 3}（如限流）

并发量:
├─ 正常并发: {并发量}（如 100 QPS）
├─ 峰值并发: {并发量}（如 1000 QPS）
├─ 超限: {处理方式}（如返回 503 错误、限流）
└─ 优化策略:
   ├─ 负载均衡
   ├─ 限流（令牌桶、漏桶）
   └─ 降级

数据量:
├─ 单次查询: 最多 {数量} 条（如最多 100 条）
├─ 批量操作: 最多 {数量} 条（如最多 1000 条）
├─ 超限: {处理方式}
└─ 优化策略:
   ├─ 分页
   ├─ 批量异步处理
   └─ 流式处理
```

---

## 5. 错误处理设计模板

### 5.1 错误码设计规范

```
错误码命名规范:
├─ 格式: {HTTP 状态码}{序号}
│  - 示例: 4001, 4002, 5001
├─ 分类:
│  ├─ 400x: 请求错误
│  ├─ 401x: 认证错误
│  ├─ 403x: 授权错误
│  ├─ 404x: 资源不存在
│  ├─ 500x: 内部错误
│  ├─ 502x: 网关错误
│  └─ 503x: 服务不可用
└─ 说明: 使用描述性名称
```

### 5.2 错误信息设计原则

```
用户友好:
├─ 使用用户可理解的语言
└─ 示例: "用户名或密码错误"（而不是"Authentication failed"）

清晰明确:
├─ 说明错误原因和解决方案
└─ 示例: "密码长度至少 6 字符，请重新输入"

安全性:
├─ 不暴露敏感信息
└─ 示例: "用户名或密码错误"（而不是"用户名不存在"）

一致性:
├─ 同类错误使用统一的格式
└─ 示例: 所有验证错误都用"XX 不能为空"或"XX 格式错误"
```

### 5.3 重试机制模板

```
自动重试:
├─ 适用: {适用场景}（如网络超时、临时故障）
├─ 策略: {重试策略}（如指数退避：1s、2s、4s）
├─ 次数: 最多重试 {次数} 次（如 3 次）
└─ 失败: {失败处理}（如返回错误给用户）

手动重试:
├─ 适用: {适用场景}（如用户操作失败）
├─ 策略: {重试策略}（如提供"重试"按钮）
├─ 次数: {次数限制}（如不限制）
└─ 提示: {提示信息}（如清晰的错误信息和重试指引）

不重试:
├─ 适用: {适用场景}（如业务错误、参数错误、权限错误）
├─ 策略: {策略}（如直接返回错误）
└─ 提示: {提示信息}（如说明错误原因）
```

### 5.4 降级方案模板

```
{降级场景名称}:
├─ 场景: {场景描述}
│  - 描述什么情况下触发降级
│  - 示例: 推荐系统故障
├─ 降级方案: {降级方案}
│  - 具体的降级措施
│  - 示例: 返回热门商品或默认推荐
├─ 用户体验: {用户体验描述}
│  - 用户感知到的变化
│  - 示例: 用户感知不到异常
└─ 恢复: {恢复机制}
   - 如何恢复正常服务
   - 示例: 推荐系统恢复后自动恢复
```

---

## 6. 功能间交互设计模板

### 6.1 功能依赖模板

```
功能: {功能名称}

依赖功能:
├─ {依赖功能 1 名称}: {依赖描述}
│  ├─ 检查: {检查内容}
│  └─ 异常: {异常情况} → {异常处理}
├─ {依赖功能 2 名称}: {依赖描述}
│  ├─ 调用: {调用接口}
│  └─ 异常: {异常情况} → {异常处理}
└─ {依赖功能 3 名称}: {依赖描述}
   ├─ 调用: {调用接口}
   └─ 异常: {异常情况} → {异常处理}

后续功能:
├─ {后续功能 1}: {触发条件}
├─ {后续功能 2}: {触发条件}
└─ {后续功能 3}: {触发条件}
```

### 6.2 交互流程模板

```
交互流程: {流程名称}

步骤 {序号}: {步骤名称}
├─ 调用: {调用功能}
├─ 输入: {输入内容}
├─ 输出: {输出内容} 或 {异常情况}
└─ 异常处理:
   ├─ {异常 1} → {处理方式}
   ├─ {异常 2} → {处理方式}
   └─ {异常 3} → {处理方式}
```

### 6.3 数据传递模板

```
数据传递方式:
├─ 同步调用: {调用描述}
│  ├─ 适用: {适用场景}
│  └─ 实现: {实现方式}（如 HTTP/gRPC 同步调用）
├─ 异步调用: {调用描述}
│  ├─ 适用: {适用场景}
│  └─ 实现: {实现方式}（如 Kafka/RabbitMQ 消息队列）
└─ 事件驱动: {调用描述}
   ├─ 适用: {适用场景}
   └─ 实现: {实现方式}（如事件总线 EventBus）

数据一致性:
├─ 强一致性: {场景描述}
│  ├─ 实现: {实现方式}（如事务、分布式事务）
│  └─ 适用: {适用场景}
├─ 最终一致性: {场景描述}
│  ├─ 实现: {实现方式}（如消息队列、补偿机制）
│  └─ 适用: {适用场景}
└─ 弱一致性: {场景描述}
   ├─ 实现: {实现方式}（如异步、重试）
   └─ 适用: {适用场景}
```

---

## 7. 常见错误和解决方案

### 7.1 功能边界不清

**问题**: 功能设计包含了技术实现细节（如 API path、数据库表）

**原因**: 没有明确功能设计和技术实现的边界

**解决方案**:
- 功能设计只关注功能逻辑（用例、输入输出、边界、错误）
- 技术细节留给其他 Skill：
  - API path → `design-api` Skill
  - 数据库表 → `design-db` Skill
  - 技术架构 → `design-architect` Skill

### 7.2 用例不完整

**问题**: 只考虑了正常用例，忽略了异常和边界用例

**原因**: 对业务理解不足，没有充分考虑异常情况

**解决方案**:
- 充分识别各种异常情况（≥ 3 个）
- 覆盖边界条件（≥ 3 个）
- 请业务专家审查

### 7.3 错误处理不友好

**问题**: 错误信息过于技术化，用户无法理解

**原因**: 直接返回技术错误信息，没有考虑用户体验

**解决方案**:
- 使用用户可理解的语言
- 提供清晰的解决方案
- 不暴露技术细节和敏感信息

### 7.4 输入输出定义不清

**问题**: 输入输出字段不完整，缺少类型和验证规则

**原因**: 对需求理解不足，没有详细分析输入输出

**解决方案**:
- 列出所有输入输出字段
- 明确类型、格式、验证规则
- 提供清晰的示例

### 7.5 忽略并发和性能

**问题**: 未考虑并发场景和性能边界

**原因**: 对系统负载估计不足，缺少性能指标定义

**解决方案**:
- 识别并发场景（重复提交、库存扣减等）
- 定义性能指标（响应时间、并发量、数据量）
- 设计限流和降级方案

---

## 8. 功能设计文档结构

### 8.1 完整文档结构

```markdown
---
change_id: "{变更 ID}"
stage: "design"
document_type: "feature-design"
created_at: "{创建时间}"
updated_at: "{更新时间}"
version: "{版本号}"
---

# 功能详细设计文档

## 1. 功能分解

### 1.1 功能模块列表

{功能树结构}

### 1.2 优先级说明

{优先级划分和说明}

---

## 2. 用例设计

### 2.1 功能 1: {功能名称}

#### 2.1.1 正常用例

{正常用例描述}

#### 2.1.2 异常用例

{异常用例列表}

#### 2.1.3 边界用例

{边界用例列表}

### 2.2 功能 2: {功能名称}

{重复 2.1 的结构}

---

## 3. 输入输出定义

### 3.1 功能 1: {功能名称}

#### 3.1.1 输入字段

{输入字段定义}

#### 3.1.2 成功输出

{成功输出定义}

#### 3.1.3 失败输出

{失败输出定义}

#### 3.1.4 错误码定义

{错误码列表}

### 3.2 功能 2: {功能名称}

{重复 3.1 的结构}

---

## 4. 边界条件处理

### 4.1 数据边界

{数据边界定义}

### 4.2 并发边界

{并发边界处理}

### 4.3 性能边界

{性能边界定义}

### 4.4 状态边界

{状态边界定义}

---

## 5. 错误处理设计

### 5.1 错误分类

{错误码分类}

### 5.2 错误信息设计

{错误信息列表}

### 5.3 重试机制

{重试机制设计}

### 5.4 降级方案

{降级方案设计}

---

## 6. 功能间交互设计

### 6.1 功能依赖

{功能依赖关系}

### 6.2 交互流程

{交互流程设计}

### 6.3 数据传递

{数据传递方式}

### 6.4 数据一致性

{数据一致性要求}

---

## 7. 附录

### 7.1 术语表

{关键术语定义}

### 7.2 参考文档

{参考文档链接}
```

---

**使用建议**: 本文档作为功能设计时的参考，确保功能设计完整、规范、可执行。模板可根据实际需求调整。
