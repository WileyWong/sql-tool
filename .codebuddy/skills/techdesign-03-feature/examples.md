# 功能详细设计示例

本文档提供 3 个完整的功能设计示例，涵盖不同场景和复杂度。

---

## 示例 1: 用户登录功能（基础场景）

### 1.1 功能分解

```
功能模块: 用户认证
├─ 用户名密码登录（P0）
│  ├─ 输入用户名和密码
│  ├─ 验证用户名和密码
│  └─ 生成登录凭证（Token）
├─ 手机号验证码登录（P1）
│  ├─ 输入手机号
│  ├─ 发送验证码
│  ├─ 输入验证码
│  └─ 验证验证码，生成登录凭证
├─ 第三方登录（P2）
│  ├─ 跳转到第三方授权页面
│  ├─ 用户授权
│  └─ 获取第三方用户信息，生成登录凭证
└─ 记住登录状态（P1）
   └─ 延长 Token 有效期（如 7 天）
```

### 1.2 用例设计

#### 正常用例

```
用例 ID: UC-LOGIN-001
用例名称: 用户名密码登录
参与者: 用户
前置条件: 用户已注册

主流程:
1. 用户打开登录页面
2. 用户输入用户名
3. 用户输入密码
4. 用户点击"登录"按钮
5. 系统验证用户名和密码
6. 系统生成 Token
7. 系统返回 Token 给用户
8. 用户跳转到首页

后置条件: 用户已登录，Token 有效期 24 小时
```

#### 异常用例

**异常用例 1: 用户名不存在**
```
触发条件: 步骤 5，用户名在数据库中不存在
处理流程:
  1. 系统返回错误: "用户名或密码错误"（安全考虑，不暴露具体错误）
  2. 用户可以重新输入
  3. 返回步骤 2
结果: 登录失败，用户停留在登录页面
```

**异常用例 2: 密码错误**
```
触发条件: 步骤 5，密码与数据库中不匹配
处理流程:
  1. 系统返回错误: "用户名或密码错误"
  2. 系统记录登录失败次数
  3. 如果失败次数 ≥ 5，冻结账户 1 小时
  4. 用户可以重新输入
  5. 返回步骤 3
结果: 登录失败，可能触发账户冻结
```

**异常用例 3: 账户被冻结**
```
触发条件: 步骤 5，账户处于冻结状态
处理流程:
  1. 系统返回错误: "账户已冻结，请 1 小时后重试"
  2. 用户无法登录
结果: 登录失败，用户需要等待解冻
```

**异常用例 4: 网络超时**
```
触发条件: 步骤 5-7，网络连接超时
处理流程:
  1. 系统返回错误: "网络连接超时，请重试"
  2. 用户可以点击"重试"
  3. 返回步骤 5
结果: 登录失败，用户可以重试
```

#### 边界用例

**边界用例 1: 用户名为空**
```
触发条件: 用户未输入用户名
处理: 前端提示"请输入用户名"，禁用登录按钮
结果: 无法提交
```

**边界用例 2: 密码为空**
```
触发条件: 用户未输入密码
处理: 前端提示"请输入密码"，禁用登录按钮
结果: 无法提交
```

**边界用例 3: 用户名长度超限**
```
触发条件: 用户名长度 > 50 字符
处理: 前端限制输入长度，后端返回"用户名长度不能超过 50 字符"
结果: 无法提交或后端拒绝
```

**边界用例 4: 密码长度不足**
```
触发条件: 密码长度 < 6 字符
处理: 前端提示"密码长度至少 6 字符"
结果: 无法提交
```

### 1.3 输入输出定义

#### 输入字段

```
username (用户名)
├─ 类型: String
├─ 长度: 1-50 字符
├─ 格式: 字母、数字、下划线
├─ 必填: 是
├─ 默认值: 无
├─ 示例: "john_doe"
└─ 验证规则:
   ├─ 非空检查
   ├─ 长度检查: 1 ≤ len(username) ≤ 50
   └─ 格式检查: ^[a-zA-Z0-9_]+$

password (密码)
├─ 类型: String
├─ 长度: 6-50 字符
├─ 格式: 不限制
├─ 必填: 是
├─ 默认值: 无
├─ 示例: "password123"
└─ 验证规则:
   ├─ 非空检查
   └─ 长度检查: 6 ≤ len(password) ≤ 50

remember_me (记住我)
├─ 类型: Boolean
├─ 必填: 否
├─ 默认值: false
└─ 示例: true
```

#### 成功输出

```json
{
  "user_id": 123,
  "username": "john_doe",
  "email": "john@example.com",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expires_at": "2025-11-08T10:00:00Z"
}
```

#### 失败输出

```json
{
  "error_code": 4001,
  "error_message": "用户名或密码错误",
  "error_details": null
}
```

#### 错误码定义

```
4001: 用户名或密码错误
4002: 账户不存在
4003: 账户已冻结
4004: 参数验证失败
4005: Token 过期
4006: Token 无效
5000: 服务器内部错误
```

### 1.4 边界条件处理

#### 数据边界

```
字符串长度:
├─ 用户名: 1-50 字符
│  ├─ 最小长度: 1 字符
│  ├─ 最大长度: 50 字符
│  ├─ 空字符串: 拒绝
│  └─ 超长字符串: 截断或拒绝
└─ 密码: 6-50 字符
   ├─ 最小长度: 6 字符
   ├─ 最大长度: 50 字符
   ├─ 空字符串: 拒绝
   └─ 超长字符串: 截断或拒绝

特殊字符:
└─ 用户名: 只允许字母、数字、下划线
   └─ 处理: 过滤或拒绝
```

#### 并发边界

```
重复提交:
├─ 场景: 用户多次点击"登录"按钮
├─ 处理:
│  ├─ 前端: 禁用按钮（点击后灰掉）
│  └─ 后端: 幂等性检查
└─ 结果: 只处理一次

同时登录:
├─ 场景: 用户在手机和电脑同时登录
├─ 处理: 允许多设备登录（生成多个 Token）
└─ 结果: 多个 Token 都有效
```

#### 性能边界

```
响应时间:
├─ 正常响应: < 200ms
├─ 慢查询: 200-1000ms（需要优化）
└─ 超时: > 5000ms（返回超时错误）

并发量:
├─ 正常并发: 100 QPS
├─ 峰值并发: 1000 QPS
└─ 超限: 返回 503 错误、限流
```

### 1.5 错误处理设计

#### 错误分类

```
客户端错误 (4xx):
├─ 4001: 用户名或密码错误
├─ 4002: 账户不存在
├─ 4003: 账户已冻结
└─ 4004: 参数验证失败

服务器错误 (5xx):
├─ 5000: 服务器内部错误
└─ 5031: 服务暂时不可用
```

#### 重试机制

```
自动重试:
├─ 适用: 网络超时、临时故障
├─ 策略: 指数退避（1s、2s、4s）
├─ 次数: 最多重试 3 次
└─ 失败: 返回错误给用户

手动重试:
├─ 适用: 用户操作失败
├─ 策略: 提供"重试"按钮
└─ 提示: "网络连接超时，请重试"

不重试:
├─ 适用: 业务错误（如参数错误、权限错误）
└─ 策略: 直接返回错误
```

#### 降级方案

```
限流降级:
├─ 场景: 并发量过高
├─ 降级方案: 限制部分用户访问
├─ 用户体验: 返回"系统繁忙，请稍后重试"
└─ 恢复: 并发量降低后自动恢复
```

### 1.6 功能间交互设计

#### 功能依赖

```
无依赖（独立功能）
```

#### 后续功能

```
登录成功后 → 生成 Token → 用户可以访问需要认证的接口
```

---

## 示例 2: 创建订单功能（复杂场景）

### 2.1 功能分解

```
功能模块: 订单管理
├─ 创建订单（P0）
│  ├─ 验证用户登录状态
│  ├─ 查询商品信息
│  ├─ 检查库存
│  ├─ 验证收货地址
│  ├─ 计算订单金额
│  └─ 保存订单到数据库
├─ 取消订单（P0）
├─ 支付订单（P0）
└─ 退款订单（P1）
```

### 2.2 用例设计（简化）

#### 正常用例

```
用例 ID: UC-ORDER-001
用例名称: 创建订单
参与者: 用户
前置条件: 用户已登录、商品已选择、收货地址已填写

主流程:
1. 用户点击"提交订单"按钮
2. 系统验证用户登录状态
3. 系统查询商品信息
4. 系统检查库存
5. 系统验证收货地址
6. 系统计算订单金额
7. 系统保存订单到数据库
8. 系统返回订单信息
9. 用户跳转到支付页面

后置条件: 订单已创建，状态为"待支付"
```

#### 异常用例（简化）

```
异常用例 1: Token 过期
异常用例 2: 商品不存在
异常用例 3: 库存不足
异常用例 4: 地址无效
异常用例 5: 数据库异常
```

### 2.3 输入输出定义（简化）

#### 输入字段

```
user_token (用户凭证): String, 必需
items (商品列表): Array<Object>, 必需
  - product_id: Integer, 商品 ID
  - quantity: Integer, 数量
address_id (收货地址 ID): Integer, 必需
```

#### 成功输出

```json
{
  "order_id": 1001,
  "order_no": "ORD20251107001",
  "status": "PENDING",
  "total_amount": 199.99,
  "created_at": "2025-11-07T10:00:00Z"
}
```

### 2.4 边界条件处理（简化）

#### 并发边界（重点）

```
库存扣减（防止超卖）:
├─ 场景: 多个用户同时购买最后一件商品
├─ 处理方式:
│  ├─ 乐观锁: 使用 version 字段
│  ├─ 悲观锁: SELECT FOR UPDATE
│  └─ 分布式锁: Redis 分布式锁
└─ 结果: 只有一个用户成功，其他用户返回"库存不足"

订单号生成（防止重复）:
├─ 场景: 并发创建订单
├─ 处理方式:
│  ├─ 数据库唯一约束
│  └─ 分布式 ID 生成器（雪花算法）
└─ 结果: 每个订单号唯一
```

### 2.5 错误处理设计（简化）

#### 错误码定义

```
4011: 未登录
4012: Token 过期
4043: 商品不存在
4044: 库存不足
4045: 地址无效
5001: 数据库异常
```

### 2.6 功能间交互设计（重点）

#### 功能依赖

```
功能: 创建订单

依赖功能:
├─ 用户认证: 需要用户已登录
│  ├─ 检查: 验证 Token 是否有效
│  └─ 异常: Token 过期 → 返回 4012 错误
│
├─ 商品查询: 需要查询商品信息
│  ├─ 调用: 商品服务的查询接口
│  └─ 异常: 商品不存在 → 返回 4043 错误
│
├─ 库存检查: 需要检查库存是否充足
│  ├─ 调用: 库存服务的检查接口
│  └─ 异常: 库存不足 → 返回 4044 错误
│
└─ 地址验证: 需要验证收货地址
   ├─ 调用: 地址服务的验证接口
   └─ 异常: 地址无效 → 返回 4045 错误
```

#### 交互流程

```
交互流程: 创建订单

步骤 1: 验证用户登录状态
├─ 调用: 用户认证功能
├─ 输入: Token
├─ 输出: 用户信息 或 认证失败
└─ 异常处理:
   ├─ Token 过期 → 返回 4012 错误
   └─ Token 无效 → 返回 4013 错误

步骤 2: 查询商品信息
├─ 调用: 商品查询功能
├─ 输入: 商品 ID 列表
├─ 输出: 商品详情列表 或 商品不存在
└─ 异常处理:
   ├─ 商品不存在 → 返回 4043 错误
   └─ 商品已下架 → 返回业务错误

步骤 3: 检查库存（使用分布式锁）
├─ 调用: 库存检查功能
├─ 输入: 商品 ID、数量
├─ 输出: 库存充足 或 库存不足
├─ 加锁: Redis 分布式锁（锁定商品）
└─ 异常处理:
   ├─ 库存不足 → 返回 4044 错误
   └─ 库存服务异常 → 返回 5001 错误

步骤 4: 创建订单
├─ 操作: 保存订单到数据库
├─ 输出: 订单信息
└─ 异常处理:
   ├─ 数据库异常 → 返回 5001 错误
   └─ 订单号重复 → 返回业务错误（幂等性保护）

步骤 5: 发送通知（异步）
├─ 调用: 通知功能（异步）
├─ 输入: 订单信息
└─ 异常处理:
   └─ 通知失败不影响订单创建（记录日志即可）
```

#### 数据传递

```
数据传递方式:
├─ 同步调用: 查询商品信息 → HTTP/gRPC
├─ 异步调用: 发送通知 → Kafka 消息队列
└─ 事件驱动: 订单创建事件 → 触发支付流程

数据一致性:
├─ 强一致性: 订单金额必须准确（使用事务）
├─ 最终一致性: 库存扣减可能延迟（使用消息队列）
└─ 弱一致性: 通知可能延迟或失败（异步、重试）
```

---

## 示例 3: 商品搜索功能（性能场景）

### 3.1 功能分解

```
功能模块: 商品搜索
├─ 关键词搜索（P0）
├─ 分类筛选（P0）
├─ 价格筛选（P1）
├─ 排序（P1）
└─ 分页（P0）
```

### 3.2 输入输出定义（简化）

#### 输入字段

```
keyword (关键词): String, 可选
category_id (分类 ID): Integer, 可选
min_price (最低价格): Decimal, 可选
max_price (最高价格): Decimal, 可选
sort_by (排序字段): String, 可选, 默认 "relevance"
  - 可选值: relevance（相关性）、price_asc（价格升序）、price_desc（价格降序）、sales（销量）
page (页码): Integer, 可选, 默认 1
page_size (每页数量): Integer, 可选, 默认 20
```

#### 成功输出

```json
{
  "total": 1000,
  "page": 1,
  "page_size": 20,
  "items": [
    {
      "product_id": 1,
      "name": "商品名称",
      "price": 99.99,
      "sales": 1000
    }
  ]
}
```

### 3.3 边界条件处理（性能重点）

#### 性能边界

```
响应时间:
├─ 正常响应: < 200ms
│  └─ 目标: P95 响应时间 < 200ms
├─ 慢查询: 200-1000ms
│  └─ 处理: 记录慢查询日志，优化 SQL
├─ 超时: > 5000ms
│  └─ 处理: 返回"请求超时，请重试"
└─ 优化策略:
   ├─ 使用 Elasticsearch 全文搜索
   ├─ 热数据缓存到 Redis（TTL 5 分钟）
   └─ 分页限制（最多查询 100 页）

并发量:
├─ 正常并发: 500 QPS
├─ 峰值并发: 5000 QPS
└─ 超限: 限流（令牌桶算法）

数据量:
├─ 单次查询: 最多 100 条（分页）
│  └─ 处理: page_size 最大 100
├─ 最大页码: 100 页
│  └─ 处理: page > 100 返回错误
└─ 优化策略:
   └─ 使用游标分页（cursor-based pagination）
```

#### 数据边界

```
价格筛选:
├─ min_price: 0 ≤ min_price ≤ 999999
├─ max_price: 0 ≤ max_price ≤ 999999
└─ 验证: min_price ≤ max_price

分页:
├─ page: 1 ≤ page ≤ 100
├─ page_size: 1 ≤ page_size ≤ 100
└─ 验证: page 和 page_size 必须为正整数
```

### 3.4 错误处理设计（简化）

#### 降级方案（重点）

```
搜索服务降级:
├─ 场景: Elasticsearch 服务故障
├─ 降级方案: 切换到数据库查询（性能较差但可用）
├─ 用户体验: 用户感知响应稍慢
└─ 恢复: Elasticsearch 恢复后切换回来

缓存降级:
├─ 场景: Redis 服务故障
├─ 降级方案: 直接查询 Elasticsearch（跳过缓存）
├─ 用户体验: 用户感知响应稍慢
└─ 恢复: Redis 恢复后恢复缓存

限流降级:
├─ 场景: 并发量过高（> 5000 QPS）
├─ 降级方案: 返回"系统繁忙，请稍后重试"
├─ 用户体验: 部分用户无法搜索
└─ 恢复: 并发量降低后自动恢复
```

---

**使用建议**: 根据功能复杂度选择合适的示例参考。示例 1 适合基础功能，示例 2 适合复杂功能（多依赖、并发），示例 3 适合高性能场景。
